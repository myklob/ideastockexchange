"""
SQL Schema and Seed File Generator.

Creates a relational database structure where every argument is a "Belief Node."
Every relation between a parent and child stores its specific Linkage Score.
Generates INSERT scripts that populate the "Arena" with initial contenders.
"""

from __future__ import annotations

import os
from pathlib import Path

from pipeline.config import PipelineConfig, DB_NAME, DB_CHARSET, DB_COLLATION
from pipeline.models.belief_node import ArgumentTree


class SqlGenerator:
    """Generate SQL schema and seed files from an ArgumentTree."""

    def __init__(self, config: PipelineConfig):
        self.config = config

    def generate(self, tree: ArgumentTree) -> dict[str, str]:
        """
        Generate SQL files from the argument tree.

        Returns:
            Dict mapping filename -> SQL content.
        """
        schema_sql = self._generate_schema()
        seed_sql = self._generate_seed(tree)
        views_sql = self._generate_views()
        procedures_sql = self._generate_procedures()

        files = {
            "001_schema.sql": schema_sql,
            "002_seed.sql": seed_sql,
            "003_views.sql": views_sql,
            "004_procedures.sql": procedures_sql,
        }

        return files

    def write(self, tree: ArgumentTree):
        """Generate and write SQL files to the output directory."""
        files = self.generate(tree)
        out_dir = Path(self.config.sql_output_dir)
        out_dir.mkdir(parents=True, exist_ok=True)

        for filename, content in files.items():
            filepath = out_dir / filename
            filepath.write_text(content, encoding="utf-8")

    def _generate_schema(self) -> str:
        """Generate the DDL for the belief arena database."""
        db = self.config.db_name
        return f"""\
-- ============================================================
-- ISE Justification Pipeline: Database Schema
-- Generated by the ISE Pipeline
-- ============================================================

CREATE DATABASE IF NOT EXISTS `{db}`
  CHARACTER SET {DB_CHARSET}
  COLLATE {DB_COLLATION};

USE `{db}`;

-- ── Belief Nodes ────────────────────────────────────────────
-- Every row from the source spreadsheet becomes a node in this table.
-- Each node is a fighter in the arena.

CREATE TABLE IF NOT EXISTS `belief_nodes` (
  `id`               VARCHAR(64)    NOT NULL,
  `statement`        TEXT           NOT NULL,
  `category`         VARCHAR(255)   DEFAULT '',
  `subcategory`      VARCHAR(255)   DEFAULT '',
  `parent_id`        VARCHAR(64)    DEFAULT NULL,
  `side`             ENUM('supporting','weakening') DEFAULT 'supporting',

  -- Four fitness metrics
  `truth_score`      DECIMAL(5,4)   DEFAULT 0.5000,
  `linkage_score`    DECIMAL(5,4)   DEFAULT 0.5000,
  `importance_score` DECIMAL(5,4)   DEFAULT 0.5000,
  `uniqueness_score` DECIMAL(5,4)   DEFAULT 1.0000,

  -- Evidence metadata
  `source_url`       TEXT           DEFAULT '',
  `evidence_type`    VARCHAR(10)    DEFAULT 'T3',

  -- Computed scores (updated by the scoring engine)
  `reason_rank`      DECIMAL(10,6)  DEFAULT 0.000000,
  `propagated_score` DECIMAL(10,6)  DEFAULT 0.000000,

  -- Timestamps
  `created_at`       TIMESTAMP      DEFAULT CURRENT_TIMESTAMP,
  `updated_at`       TIMESTAMP      DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  PRIMARY KEY (`id`),
  INDEX `idx_parent` (`parent_id`),
  INDEX `idx_category` (`category`),
  INDEX `idx_side` (`side`),
  INDEX `idx_reason_rank` (`reason_rank` DESC),
  INDEX `idx_propagated_score` (`propagated_score` DESC),

  CONSTRAINT `fk_parent`
    FOREIGN KEY (`parent_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE SET NULL
    ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET={DB_CHARSET} COLLATE={DB_COLLATION};


-- ── Linkage Relations ───────────────────────────────────────
-- Explicit parent-child relationship with linkage metadata.
-- This table enables efficient traversal and stores the specific
-- linkage score for every edge in the argument graph.

CREATE TABLE IF NOT EXISTS `belief_linkages` (
  `id`               INT            AUTO_INCREMENT PRIMARY KEY,
  `parent_id`        VARCHAR(64)    NOT NULL,
  `child_id`         VARCHAR(64)    NOT NULL,
  `side`             ENUM('supporting','weakening') DEFAULT 'supporting',
  `linkage_score`    DECIMAL(5,4)   DEFAULT 0.5000,
  `linkage_type`     VARCHAR(50)    DEFAULT 'contextual',

  `created_at`       TIMESTAMP      DEFAULT CURRENT_TIMESTAMP,
  `updated_at`       TIMESTAMP      DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX `idx_parent` (`parent_id`),
  INDEX `idx_child` (`child_id`),
  UNIQUE KEY `uq_parent_child` (`parent_id`, `child_id`),

  CONSTRAINT `fk_linkage_parent`
    FOREIGN KEY (`parent_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_linkage_child`
    FOREIGN KEY (`child_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET={DB_CHARSET} COLLATE={DB_COLLATION};


-- ── Score History ───────────────────────────────────────────
-- Audit trail of score changes. Nodes are never deleted;
-- their score history is preserved.

CREATE TABLE IF NOT EXISTS `score_history` (
  `id`               INT            AUTO_INCREMENT PRIMARY KEY,
  `belief_id`        VARCHAR(64)    NOT NULL,
  `reason_rank`      DECIMAL(10,6)  NOT NULL,
  `propagated_score` DECIMAL(10,6)  NOT NULL,
  `truth_score`      DECIMAL(5,4)   NOT NULL,
  `linkage_score`    DECIMAL(5,4)   NOT NULL,
  `importance_score` DECIMAL(5,4)   NOT NULL,
  `uniqueness_score` DECIMAL(5,4)   NOT NULL,
  `recorded_at`      TIMESTAMP      DEFAULT CURRENT_TIMESTAMP,

  INDEX `idx_belief` (`belief_id`),
  INDEX `idx_recorded` (`recorded_at`),

  CONSTRAINT `fk_history_belief`
    FOREIGN KEY (`belief_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET={DB_CHARSET} COLLATE={DB_COLLATION};


-- ── Similarity Cache ────────────────────────────────────────
-- Stores pairwise semantic similarity between sibling nodes.
-- Used by the uniqueness penalty system.

CREATE TABLE IF NOT EXISTS `similarity_cache` (
  `id`               INT            AUTO_INCREMENT PRIMARY KEY,
  `node_a_id`        VARCHAR(64)    NOT NULL,
  `node_b_id`        VARCHAR(64)    NOT NULL,
  `similarity`       DECIMAL(5,4)   NOT NULL,
  `computed_at`      TIMESTAMP      DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY `uq_pair` (`node_a_id`, `node_b_id`),
  INDEX `idx_node_a` (`node_a_id`),
  INDEX `idx_node_b` (`node_b_id`),

  CONSTRAINT `fk_sim_a`
    FOREIGN KEY (`node_a_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_sim_b`
    FOREIGN KEY (`node_b_id`) REFERENCES `belief_nodes`(`id`)
    ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET={DB_CHARSET} COLLATE={DB_COLLATION};
"""

    def _generate_seed(self, tree: ArgumentTree) -> str:
        """Generate INSERT statements from the argument tree."""
        lines = [
            "-- ============================================================",
            "-- ISE Justification Pipeline: Seed Data",
            "-- Populates the Arena with initial contenders",
            "-- ============================================================",
            "",
            f"USE `{self.config.db_name}`;",
            "",
            "-- Disable foreign key checks for bulk insert",
            "SET FOREIGN_KEY_CHECKS = 0;",
            "",
        ]

        # Insert root nodes first (no parent), then children
        # This respects foreign key constraints
        roots = [n for n in tree.nodes.values() if n.parent_id is None]
        children = [n for n in tree.nodes.values() if n.parent_id is not None]

        for group_label, nodes in [("Root Beliefs", roots), ("Child Arguments", children)]:
            if not nodes:
                continue
            lines.append(f"-- ── {group_label} ────")

            for node in nodes:
                stmt = self._escape_sql(node.statement)
                cat = self._escape_sql(node.category)
                subcat = self._escape_sql(node.subcategory)
                url = self._escape_sql(node.source_url)
                parent = f"'{node.parent_id}'" if node.parent_id else "NULL"

                lines.append(
                    f"INSERT INTO `belief_nodes` "
                    f"(`id`, `statement`, `category`, `subcategory`, `parent_id`, `side`, "
                    f"`truth_score`, `linkage_score`, `importance_score`, `uniqueness_score`, "
                    f"`source_url`, `evidence_type`, `reason_rank`, `propagated_score`) "
                    f"VALUES ("
                    f"'{node.belief_id}', '{stmt}', '{cat}', '{subcat}', {parent}, '{node.side}', "
                    f"{node.truth_score:.4f}, {node.linkage_score:.4f}, "
                    f"{node.importance_score:.4f}, {node.uniqueness_score:.4f}, "
                    f"'{url}', '{node.evidence_type}', "
                    f"{node.reason_rank:.6f}, {node.propagated_score:.6f}"
                    f");"
                )

        # Insert linkage relations
        lines.append("")
        lines.append("-- ── Linkage Relations ────")

        for node in tree.nodes.values():
            if node.parent_id and node.parent_id in tree.nodes:
                lines.append(
                    f"INSERT INTO `belief_linkages` "
                    f"(`parent_id`, `child_id`, `side`, `linkage_score`) "
                    f"VALUES ('{node.parent_id}', '{node.belief_id}', "
                    f"'{node.side}', {node.linkage_score:.4f});"
                )

        lines.append("")
        lines.append("SET FOREIGN_KEY_CHECKS = 1;")
        lines.append("")

        return "\n".join(lines)

    def _generate_views(self) -> str:
        """Generate useful SQL views for querying the arena."""
        db = self.config.db_name
        return f"""\
-- ============================================================
-- ISE Justification Pipeline: Views
-- ============================================================

USE `{db}`;

-- Leaderboard: all root beliefs ranked by propagated score
CREATE OR REPLACE VIEW `v_leaderboard` AS
SELECT
  bn.id,
  bn.statement,
  bn.category,
  bn.reason_rank,
  bn.propagated_score,
  bn.truth_score,
  bn.linkage_score,
  bn.importance_score,
  bn.uniqueness_score,
  (SELECT COUNT(*) FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'supporting') AS pro_count,
  (SELECT COUNT(*) FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'weakening') AS con_count
FROM belief_nodes bn
WHERE bn.parent_id IS NULL
ORDER BY bn.propagated_score DESC;


-- Argument tree: parent-child with scores
CREATE OR REPLACE VIEW `v_argument_tree` AS
SELECT
  bl.parent_id,
  p.statement AS parent_statement,
  bl.child_id,
  c.statement AS child_statement,
  c.side,
  bl.linkage_score AS edge_linkage,
  c.truth_score,
  c.importance_score,
  c.uniqueness_score,
  c.reason_rank,
  c.propagated_score
FROM belief_linkages bl
JOIN belief_nodes p ON p.id = bl.parent_id
JOIN belief_nodes c ON c.id = bl.child_id
ORDER BY bl.parent_id, c.propagated_score DESC;


-- Pro/Con summary for each belief
CREATE OR REPLACE VIEW `v_pro_con_summary` AS
SELECT
  bn.id AS belief_id,
  bn.statement,
  COALESCE(pro.total_score, 0) AS total_pro_score,
  COALESCE(pro.arg_count, 0) AS pro_count,
  COALESCE(con.total_score, 0) AS total_con_score,
  COALESCE(con.arg_count, 0) AS con_count,
  COALESCE(pro.total_score, 0) - COALESCE(con.total_score, 0) AS net_score
FROM belief_nodes bn
LEFT JOIN (
  SELECT parent_id, SUM(propagated_score * linkage_score) AS total_score, COUNT(*) AS arg_count
  FROM belief_nodes WHERE side = 'supporting' AND parent_id IS NOT NULL
  GROUP BY parent_id
) pro ON pro.parent_id = bn.id
LEFT JOIN (
  SELECT parent_id, SUM(propagated_score * linkage_score) AS total_score, COUNT(*) AS arg_count
  FROM belief_nodes WHERE side = 'weakening' AND parent_id IS NOT NULL
  GROUP BY parent_id
) con ON con.parent_id = bn.id
ORDER BY net_score DESC;
"""

    def _generate_procedures(self) -> str:
        """Generate stored procedures for score recalculation."""
        db = self.config.db_name
        return f"""\
-- ============================================================
-- ISE Justification Pipeline: Stored Procedures
-- ============================================================

USE `{db}`;

DELIMITER //

-- Recalculate propagated scores bottom-up for the entire tree.
-- This is the "referee" that re-evaluates all fighters after any update.
CREATE PROCEDURE IF NOT EXISTS `sp_recalculate_scores`()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_id VARCHAR(64);
  DECLARE v_impact DECIMAL(10,6);
  DECLARE v_counter DECIMAL(10,6);
  DECLARE v_truth DECIMAL(5,4);
  DECLARE v_linkage DECIMAL(5,4);
  DECLARE v_uniqueness DECIMAL(5,4);
  DECLARE v_new_score DECIMAL(10,6);

  -- Phase 1: Reset all leaf nodes to their base rank
  UPDATE belief_nodes bn
  SET bn.reason_rank = bn.truth_score * bn.linkage_score * bn.importance_score * bn.uniqueness_score,
      bn.propagated_score = bn.truth_score * bn.linkage_score * bn.importance_score * bn.uniqueness_score
  WHERE bn.id NOT IN (SELECT DISTINCT parent_id FROM belief_nodes WHERE parent_id IS NOT NULL);

  -- Phase 2: Walk up the tree level by level
  -- We iterate until no more updates are needed (max 100 levels deep)
  SET @levels = 0;
  SET @updated = 1;

  WHILE @updated > 0 AND @levels < 100 DO
    SET @updated = 0;

    UPDATE belief_nodes bn
    SET bn.propagated_score = GREATEST(
          (
            COALESCE(
              (SELECT SUM(c.propagated_score * c.linkage_score)
               FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'supporting'),
              0
            )
            -
            COALESCE(
              (SELECT SUM(c.propagated_score * c.linkage_score)
               FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'weakening'),
              0
            )
          ) * bn.linkage_score * bn.truth_score * bn.uniqueness_score,
          0.001
        ),
        bn.reason_rank = bn.propagated_score,
        bn.updated_at = CURRENT_TIMESTAMP
    WHERE bn.id IN (SELECT DISTINCT parent_id FROM belief_nodes WHERE parent_id IS NOT NULL)
      AND bn.propagated_score != GREATEST(
          (
            COALESCE(
              (SELECT SUM(c2.propagated_score * c2.linkage_score)
               FROM belief_nodes c2 WHERE c2.parent_id = bn.id AND c2.side = 'supporting'),
              0
            )
            -
            COALESCE(
              (SELECT SUM(c2.propagated_score * c2.linkage_score)
               FROM belief_nodes c2 WHERE c2.parent_id = bn.id AND c2.side = 'weakening'),
              0
            )
          ) * bn.linkage_score * bn.truth_score * bn.uniqueness_score,
          0.001
        );

    SET @updated = ROW_COUNT();
    SET @levels = @levels + 1;
  END WHILE;

  -- Phase 3: Record score snapshot in history
  INSERT INTO score_history (belief_id, reason_rank, propagated_score,
    truth_score, linkage_score, importance_score, uniqueness_score)
  SELECT id, reason_rank, propagated_score,
    truth_score, linkage_score, importance_score, uniqueness_score
  FROM belief_nodes;

END //


-- Recalculate scores for a specific subtree (triggered when a node is updated).
CREATE PROCEDURE IF NOT EXISTS `sp_recalculate_subtree`(IN root_id VARCHAR(64))
BEGIN
  -- Update leaf nodes in this subtree
  UPDATE belief_nodes bn
  SET bn.reason_rank = bn.truth_score * bn.linkage_score * bn.importance_score * bn.uniqueness_score,
      bn.propagated_score = bn.truth_score * bn.linkage_score * bn.importance_score * bn.uniqueness_score
  WHERE bn.id NOT IN (SELECT DISTINCT parent_id FROM belief_nodes WHERE parent_id IS NOT NULL)
    AND (bn.id = root_id OR bn.parent_id = root_id);

  -- Walk up from the root
  SET @levels = 0;
  SET @updated = 1;

  WHILE @updated > 0 AND @levels < 100 DO
    SET @updated = 0;

    UPDATE belief_nodes bn
    SET bn.propagated_score = GREATEST(
          (
            COALESCE(
              (SELECT SUM(c.propagated_score * c.linkage_score)
               FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'supporting'),
              0
            )
            -
            COALESCE(
              (SELECT SUM(c.propagated_score * c.linkage_score)
               FROM belief_nodes c WHERE c.parent_id = bn.id AND c.side = 'weakening'),
              0
            )
          ) * bn.linkage_score * bn.truth_score * bn.uniqueness_score,
          0.001
        ),
        bn.reason_rank = bn.propagated_score,
        bn.updated_at = CURRENT_TIMESTAMP
    WHERE bn.id = root_id;

    SET @updated = ROW_COUNT();
    SET @levels = @levels + 1;
  END WHILE;
END //


-- Apply uniqueness penalty to a node.
CREATE PROCEDURE IF NOT EXISTS `sp_apply_uniqueness_penalty`(
  IN target_id VARCHAR(64),
  IN penalty_factor DECIMAL(5,4)
)
BEGIN
  UPDATE belief_nodes
  SET uniqueness_score = GREATEST(uniqueness_score * penalty_factor, 0.01),
      updated_at = CURRENT_TIMESTAMP
  WHERE id = target_id;

  -- Trigger re-sort of the parent's children
  SET @parent = (SELECT parent_id FROM belief_nodes WHERE id = target_id);
  IF @parent IS NOT NULL THEN
    CALL sp_recalculate_subtree(@parent);
  END IF;
END //


DELIMITER ;

-- ── Triggers for automatic re-sorting ───────────────────────
-- Whenever a sub-argument is updated or added, trigger a re-sort.

CREATE TRIGGER IF NOT EXISTS `trg_after_node_update`
AFTER UPDATE ON `belief_nodes`
FOR EACH ROW
BEGIN
  IF OLD.truth_score != NEW.truth_score
     OR OLD.linkage_score != NEW.linkage_score
     OR OLD.importance_score != NEW.importance_score
     OR OLD.uniqueness_score != NEW.uniqueness_score THEN
    -- Mark parent for recalculation (handled by application layer
    -- since MySQL triggers cannot call procedures that modify the same table)
    INSERT INTO score_history (belief_id, reason_rank, propagated_score,
      truth_score, linkage_score, importance_score, uniqueness_score)
    VALUES (NEW.id, NEW.reason_rank, NEW.propagated_score,
      NEW.truth_score, NEW.linkage_score, NEW.importance_score, NEW.uniqueness_score);
  END IF;
END;
"""

    def _escape_sql(self, value: str) -> str:
        """Escape single quotes in SQL string values."""
        if value is None:
            return ""
        return str(value).replace("\\", "\\\\").replace("'", "\\'")
