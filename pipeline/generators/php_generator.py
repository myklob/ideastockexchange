"""
PHP Logic Layer Generator.

Generates PHP templates that dynamically pull from the SQL database,
implement the ReasonRank formula, and ensure child argument scores
propagate upward to update parent conclusion scores in real time.
"""

from __future__ import annotations

from pathlib import Path

from pipeline.config import PipelineConfig
from pipeline.models.belief_node import ArgumentTree


class PhpGenerator:
    """Generate PHP files from an ArgumentTree."""

    def __init__(self, config: PipelineConfig):
        self.config = config

    def generate(self, tree: ArgumentTree) -> dict[str, str]:
        """
        Generate PHP files.

        Returns:
            Dict mapping filename -> PHP content.
        """
        files = {
            "config.php": self._generate_config(),
            "Database.php": self._generate_database_class(),
            "BeliefNode.php": self._generate_belief_node_class(),
            "ReasonRank.php": self._generate_reason_rank_engine(),
            "ArgumentTree.php": self._generate_argument_tree(),
            "belief_tree.php": self._generate_belief_tree_page(),
            "api.php": self._generate_api(),
            "index.php": self._generate_index(),
        }
        return files

    def write(self, tree: ArgumentTree):
        """Generate and write PHP files to the output directory."""
        files = self.generate(tree)
        out_dir = Path(self.config.php_output_dir)
        out_dir.mkdir(parents=True, exist_ok=True)

        for filename, content in files.items():
            filepath = out_dir / filename
            filepath.write_text(content, encoding="utf-8")

    def _generate_config(self) -> str:
        return f"""\
<?php
/**
 * ISE Justification Pipeline - Database Configuration
 * Generated by the ISE Pipeline
 */

define('DB_HOST', '{self.config.php_db_host}');
define('DB_USER', '{self.config.php_db_user}');
define('DB_PASS', '{self.config.php_db_password}');
define('DB_NAME', '{self.config.php_db_name}');

// ReasonRank constants
define('MIN_RANK_SCORE', 0.001);
define('UNIQUENESS_PENALTY_THRESHOLD', {self.config.similarity_threshold});
define('UNIQUENESS_PENALTY_FACTOR', 0.3);
define('DEBUNKED_THRESHOLD', 0.05);
"""

    def _generate_database_class(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - Database Connection
 */

require_once __DIR__ . '/config.php';

class Database {
    private static ?PDO $instance = null;

    public static function getConnection(): PDO {
        if (self::$instance === null) {
            $dsn = "mysql:host=" . DB_HOST . ";dbname=" . DB_NAME . ";charset=utf8mb4";
            self::$instance = new PDO($dsn, DB_USER, DB_PASS, [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        }
        return self::$instance;
    }
}
"""

    def _generate_belief_node_class(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - BeliefNode Model
 *
 * Every row in the database is a fighter in the arena.
 * This class handles CRUD and score queries.
 */

require_once __DIR__ . '/Database.php';

class BeliefNode {
    public string $id;
    public string $statement;
    public string $category;
    public string $subcategory;
    public ?string $parentId;
    public string $side;
    public float $truthScore;
    public float $linkageScore;
    public float $importanceScore;
    public float $uniquenessScore;
    public string $sourceUrl;
    public string $evidenceType;
    public float $reasonRank;
    public float $propagatedScore;
    /** @var string 'ECLS' (evidence→conclusion) or 'ACLS' (argument→conclusion) */
    public string $linkageScoreType;
    /** @var int Depth in the belief tree. Used for 0.5^depth attenuation. */
    public int $depth;

    /**
     * Fetch a single belief node by ID.
     */
    public static function findById(string $id): ?self {
        $db = Database::getConnection();
        $stmt = $db->prepare("SELECT * FROM belief_nodes WHERE id = :id");
        $stmt->execute(['id' => $id]);
        $row = $stmt->fetch();
        return $row ? self::fromRow($row) : null;
    }

    /**
     * Fetch all root beliefs (no parent), sorted by propagated score descending.
     */
    public static function getRoots(): array {
        $db = Database::getConnection();
        $stmt = $db->query(
            "SELECT * FROM belief_nodes WHERE parent_id IS NULL ORDER BY propagated_score DESC"
        );
        return array_map([self::class, 'fromRow'], $stmt->fetchAll());
    }

    /**
     * Fetch children of a given belief, sorted by propagated score descending.
     * Best reasoning rises to the top.
     */
    public static function getChildren(string $parentId): array {
        $db = Database::getConnection();
        $stmt = $db->prepare(
            "SELECT * FROM belief_nodes WHERE parent_id = :pid ORDER BY propagated_score DESC"
        );
        $stmt->execute(['pid' => $parentId]);
        return array_map([self::class, 'fromRow'], $stmt->fetchAll());
    }

    /**
     * Fetch supporting (pro) children sorted by score.
     */
    public static function getSupportingChildren(string $parentId): array {
        $db = Database::getConnection();
        $stmt = $db->prepare(
            "SELECT * FROM belief_nodes WHERE parent_id = :pid AND side = 'supporting' "
            . "ORDER BY propagated_score DESC"
        );
        $stmt->execute(['pid' => $parentId]);
        return array_map([self::class, 'fromRow'], $stmt->fetchAll());
    }

    /**
     * Fetch weakening (con) children sorted by score.
     */
    public static function getWeakeningChildren(string $parentId): array {
        $db = Database::getConnection();
        $stmt = $db->prepare(
            "SELECT * FROM belief_nodes WHERE parent_id = :pid AND side = 'weakening' "
            . "ORDER BY propagated_score DESC"
        );
        $stmt->execute(['pid' => $parentId]);
        return array_map([self::class, 'fromRow'], $stmt->fetchAll());
    }

    /**
     * Compute base rank: Truth * Linkage * Importance * Uniqueness
     */
    public function computeBaseRank(): float {
        $score = $this->truthScore * $this->linkageScore
                 * $this->importanceScore * $this->uniquenessScore;
        return max($score, MIN_RANK_SCORE);
    }

    /**
     * Update this node's scores in the database.
     */
    public function save(): void {
        $db = Database::getConnection();
        $stmt = $db->prepare(
            "UPDATE belief_nodes SET "
            . "truth_score = :truth, linkage_score = :linkage, "
            . "importance_score = :importance, uniqueness_score = :uniqueness, "
            . "reason_rank = :rank, propagated_score = :propagated, "
            . "linkage_score_type = :lst, depth = :depth "
            . "WHERE id = :id"
        );
        $stmt->execute([
            'truth' => $this->truthScore,
            'linkage' => $this->linkageScore,
            'importance' => $this->importanceScore,
            'uniqueness' => $this->uniquenessScore,
            'rank' => $this->reasonRank,
            'propagated' => $this->propagatedScore,
            'lst' => $this->linkageScoreType,
            'depth' => $this->depth,
            'id' => $this->id,
        ]);
    }

    /**
     * Insert a new node into the arena.
     */
    public function insert(): void {
        $db = Database::getConnection();
        $stmt = $db->prepare(
            "INSERT INTO belief_nodes "
            . "(id, statement, category, subcategory, parent_id, side, "
            . "truth_score, linkage_score, importance_score, uniqueness_score, "
            . "source_url, evidence_type, reason_rank, propagated_score, "
            . "linkage_score_type, depth) "
            . "VALUES (:id, :stmt, :cat, :subcat, :parent, :side, "
            . ":truth, :linkage, :importance, :uniqueness, "
            . ":url, :etype, :rank, :propagated, :lst, :depth)"
        );
        $stmt->execute([
            'id' => $this->id,
            'stmt' => $this->statement,
            'cat' => $this->category,
            'subcat' => $this->subcategory,
            'parent' => $this->parentId,
            'side' => $this->side,
            'truth' => $this->truthScore,
            'linkage' => $this->linkageScore,
            'importance' => $this->importanceScore,
            'uniqueness' => $this->uniquenessScore,
            'url' => $this->sourceUrl,
            'etype' => $this->evidenceType,
            'rank' => $this->reasonRank,
            'propagated' => $this->propagatedScore,
            'lst' => $this->linkageScoreType,
            'depth' => $this->depth,
        ]);

        // Also insert linkage relation if parent exists
        if ($this->parentId !== null) {
            $linkStmt = $db->prepare(
                "INSERT INTO belief_linkages (parent_id, child_id, side, linkage_score) "
                . "VALUES (:parent, :child, :side, :linkage)"
            );
            $linkStmt->execute([
                'parent' => $this->parentId,
                'child' => $this->id,
                'side' => $this->side,
                'linkage' => $this->linkageScore,
            ]);
        }
    }

    /**
     * Build a BeliefNode from a database row.
     */
    public static function fromRow(array $row): self {
        $node = new self();
        $node->id = $row['id'];
        $node->statement = $row['statement'];
        $node->category = $row['category'] ?? '';
        $node->subcategory = $row['subcategory'] ?? '';
        $node->parentId = $row['parent_id'];
        $node->side = $row['side'] ?? 'supporting';
        $node->truthScore = (float)($row['truth_score'] ?? 0.5);
        $node->linkageScore = (float)($row['linkage_score'] ?? 0.5);
        $node->importanceScore = (float)($row['importance_score'] ?? 0.5);
        $node->uniquenessScore = (float)($row['uniqueness_score'] ?? 1.0);
        $node->sourceUrl = $row['source_url'] ?? '';
        $node->evidenceType = $row['evidence_type'] ?? 'T3';
        $node->reasonRank = (float)($row['reason_rank'] ?? 0);
        $node->propagatedScore = (float)($row['propagated_score'] ?? 0);
        $node->linkageScoreType = $row['linkage_score_type'] ?? 'ACLS';
        $node->depth = (int)($row['depth'] ?? 0);
        return $node;
    }

    /**
     * Compute depth-attenuated linkage score.
     *
     * Per the ISE Linkage Scores spec, each level deeper an argument is
     * in the belief tree, its contribution is halved:
     *   attenuated = linkageScore × 0.5^depth
     *
     * Level 0 (direct argument): ×1.0
     * Level 1:                   ×0.5
     * Level 2:                   ×0.25
     */
    public function attenuatedLinkageScore(): float {
        return $this->linkageScore * (0.5 ** $this->depth);
    }

    /**
     * Return a human-readable label for the linkage score type.
     */
    public function linkageTypeLabel(): string {
        return $this->linkageScoreType === 'ECLS'
            ? 'ECLS (Evidence→Conclusion)'
            : 'ACLS (Argument→Conclusion)';
    }
}
"""

    def _generate_reason_rank_engine(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - ReasonRank Engine
 *
 * Implements the ReasonRank Formula:
 *   (Impact - CounterImpact) * Relevance * Evidence * Uniqueness
 *
 * This is the referee that calculates logical fitness and ensures
 * the strongest reasoning rises to the top tier of the rendered HTML
 * while weak reasoning sinks to the bottom.
 *
 * Child argument scores propagate upward to update parent conclusion
 * scores in real time.
 */

require_once __DIR__ . '/BeliefNode.php';

class ReasonRank {

    /**
     * Recalculate scores for the entire argument tree, bottom-up.
     *
     * 1. Compute base rank for every leaf node.
     * 2. Walk up the tree: for each parent, compute
     *    (Impact - CounterImpact) * Relevance * Evidence * Uniqueness
     * 3. No score goes below MIN_RANK_SCORE (nodes are never deleted).
     */
    public static function recalculateAll(): void {
        $db = Database::getConnection();

        // Phase 1: Get all nodes grouped by depth (leaves first)
        $allNodes = self::getAllNodesByDepth();

        // Phase 2: Process bottom-up
        foreach ($allNodes as $nodeId) {
            self::recalculateNode($nodeId);
        }
    }

    /**
     * Recalculate a single node and propagate upward to its parent.
     *
     * Called when a sub-argument is updated or new evidence is added.
     * Triggers automatic re-sorting of the parent list.
     */
    public static function recalculateNode(string $nodeId): void {
        $node = BeliefNode::findById($nodeId);
        if ($node === null) return;

        $supporting = BeliefNode::getSupportingChildren($nodeId);
        $weakening = BeliefNode::getWeakeningChildren($nodeId);

        if (empty($supporting) && empty($weakening)) {
            // Leaf node: propagated score = base rank
            $node->propagatedScore = $node->computeBaseRank();
            $node->reasonRank = $node->propagatedScore;
            $node->save();
            return;
        }

        // Impact = sum of supporting children's propagated scores * their linkage
        $impact = 0.0;
        foreach ($supporting as $child) {
            $impact += $child->propagatedScore * $child->linkageScore;
        }

        // CounterImpact = sum of weakening children's propagated scores * their linkage
        $counterImpact = 0.0;
        foreach ($weakening as $child) {
            $counterImpact += $child->propagatedScore * $child->linkageScore;
        }

        // ReasonRank formula: (Impact - CounterImpact) * Relevance * Evidence * Uniqueness
        $netImpact = $impact - $counterImpact;
        $newScore = $netImpact * $node->linkageScore * $node->truthScore * $node->uniquenessScore;
        $node->propagatedScore = max($newScore, MIN_RANK_SCORE);
        $node->reasonRank = $node->propagatedScore;
        $node->save();

        // Propagate upward: if this node has a parent, recalculate the parent too
        if ($node->parentId !== null) {
            self::recalculateNode($node->parentId);
        }
    }

    /**
     * Apply uniqueness penalty to a node.
     *
     * If a new entry has high overlap with an existing contender,
     * the code applies the Uniqueness Penalty to sink the repeat
     * to the bottom of the list.
     */
    public static function applyUniquenessPenalty(string $nodeId, float $similarity): void {
        $node = BeliefNode::findById($nodeId);
        if ($node === null) return;

        if ($similarity > UNIQUENESS_PENALTY_THRESHOLD) {
            $penalty = 1.0 - (($similarity - UNIQUENESS_PENALTY_THRESHOLD)
                              / (1.0 - UNIQUENESS_PENALTY_THRESHOLD))
                             * (1.0 - UNIQUENESS_PENALTY_FACTOR);
            $node->uniquenessScore = max($node->uniquenessScore * $penalty, 0.01);
            $node->save();

            // Trigger re-sort via score recalculation
            if ($node->parentId !== null) {
                self::recalculateNode($node->parentId);
            }
        }
    }

    /**
     * Get all node IDs ordered bottom-up (leaves first, roots last).
     */
    private static function getAllNodesByDepth(): array {
        $db = Database::getConnection();

        // Build adjacency list
        $stmt = $db->query("SELECT id, parent_id FROM belief_nodes");
        $rows = $stmt->fetchAll();

        $children = [];  // parent_id => [child_ids]
        $allIds = [];
        foreach ($rows as $row) {
            $allIds[] = $row['id'];
            if ($row['parent_id'] !== null) {
                $children[$row['parent_id']][] = $row['id'];
            }
        }

        // Topological sort via post-order DFS
        $visited = [];
        $order = [];

        foreach ($allIds as $id) {
            if (!isset($visited[$id])) {
                self::topoVisit($id, $children, $visited, $order);
            }
        }

        return $order;
    }

    private static function topoVisit(
        string $id,
        array &$children,
        array &$visited,
        array &$order
    ): void {
        $visited[$id] = true;
        foreach (($children[$id] ?? []) as $childId) {
            if (!isset($visited[$childId])) {
                self::topoVisit($childId, $children, $visited, $order);
            }
        }
        $order[] = $id;
    }

    /**
     * Get the pro/con score breakdown for a belief.
     *
     * Returns an associative array:
     * [
     *   'impact' => float,
     *   'counter_impact' => float,
     *   'net_score' => float,
     *   'pro_count' => int,
     *   'con_count' => int,
     * ]
     */
    public static function getScoreBreakdown(string $nodeId): array {
        $supporting = BeliefNode::getSupportingChildren($nodeId);
        $weakening = BeliefNode::getWeakeningChildren($nodeId);

        $impact = 0.0;
        foreach ($supporting as $child) {
            $impact += $child->propagatedScore * $child->linkageScore;
        }

        $counterImpact = 0.0;
        foreach ($weakening as $child) {
            $counterImpact += $child->propagatedScore * $child->linkageScore;
        }

        return [
            'impact' => $impact,
            'counter_impact' => $counterImpact,
            'net_score' => $impact - $counterImpact,
            'pro_count' => count($supporting),
            'con_count' => count($weakening),
        ];
    }
}
"""

    def _generate_argument_tree(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - ArgumentTree Renderer
 *
 * Recursively renders the belief hierarchy as nested HTML tables
 * in the ISE two-column Pro/Con format.
 */

require_once __DIR__ . '/BeliefNode.php';
require_once __DIR__ . '/ReasonRank.php';

class ArgumentTree {

    /**
     * Render the full argument tree for a given root belief as HTML.
     */
    public static function renderTree(string $rootId, int $depth = 0): string {
        $node = BeliefNode::findById($rootId);
        if ($node === null) return '';

        $breakdown = ReasonRank::getScoreBreakdown($rootId);
        $supporting = BeliefNode::getSupportingChildren($rootId);
        $weakening = BeliefNode::getWeakeningChildren($rootId);

        $indent = str_repeat('  ', $depth);
        $scoreClass = self::getScoreClass($node->propagatedScore);

        $html = "{$indent}<div class=\\"belief-node depth-{$depth} {$scoreClass}\\"\\n";
        $html .= "{$indent}     data-belief-id=\\"{$node->id}\\"\\n";
        $html .= "{$indent}     data-score=\\"{$node->propagatedScore}\\"\\n";
        $html .= "{$indent}     data-truth=\\"{$node->truthScore}\\"\\n";
        $html .= "{$indent}     data-linkage=\\"{$node->linkageScore}\\"\\n";
        $html .= "{$indent}     data-importance=\\"{$node->importanceScore}\\"\\n";
        $html .= "{$indent}     data-uniqueness=\\"{$node->uniquenessScore}\\">\\n";

        // Belief header with score
        $html .= "{$indent}  <div class=\\"belief-header\\">\\n";
        $html .= "{$indent}    <span class=\\"belief-statement\\">"
                 . htmlspecialchars($node->statement) . "</span>\\n";
        $html .= "{$indent}    <span class=\\"belief-score\\">"
                 . number_format($node->propagatedScore, 4) . "</span>\\n";
        $html .= "{$indent}  </div>\\n";

        // Score breakdown bar
        $html .= "{$indent}  <div class=\\"score-breakdown\\">\\n";
        $html .= "{$indent}    <span class=\\"metric\\">T:"
                 . number_format($node->truthScore, 2) . "</span>\\n";
        $html .= "{$indent}    <span class=\\"metric linkage-score\\" "
                 . "title=\\"" . htmlspecialchars($node->linkageTypeLabel()) . " | "
                 . "Attenuated (×0.5^{$node->depth}): "
                 . number_format($node->attenuatedLinkageScore(), 3)
                 . "\\">L:"
                 . number_format($node->linkageScore, 2)
                 . " <sup class=\\"linkage-type\\">" . htmlspecialchars($node->linkageScoreType) . "</sup>"
                 . "</span>\\n";
        $html .= "{$indent}    <span class=\\"metric\\">I:"
                 . number_format($node->importanceScore, 2) . "</span>\\n";
        $html .= "{$indent}    <span class=\\"metric\\">U:"
                 . number_format($node->uniquenessScore, 2) . "</span>\\n";
        if ($node->depth > 0) {
            $attenuation = 0.5 ** $node->depth;
            $html .= "{$indent}    <span class=\\"metric depth-badge\\" "
                     . "title=\\"Depth attenuation: linkage × 0.5^{$node->depth} = "
                     . number_format($attenuation, 3) . "\\">D{$node->depth} ×"
                     . number_format($attenuation, 2)
                     . "</span>\\n";
        }
        $html .= "{$indent}  </div>\\n";

        // Pro/Con table (the ISE two-column format)
        if (!empty($supporting) || !empty($weakening)) {
            $html .= "{$indent}  <table class=\\"pro-con-table\\">\\n";
            $html .= "{$indent}    <thead>\\n";
            $html .= "{$indent}      <tr>\\n";
            $html .= "{$indent}        <th class=\\"pro-header\\">Supporting ("
                     . count($supporting) . ")</th>\\n";
            $html .= "{$indent}        <th class=\\"con-header\\">Weakening ("
                     . count($weakening) . ")</th>\\n";
            $html .= "{$indent}      </tr>\\n";
            $html .= "{$indent}    </thead>\\n";
            $html .= "{$indent}    <tbody>\\n";

            $maxRows = max(count($supporting), count($weakening));
            for ($i = 0; $i < $maxRows; $i++) {
                $html .= "{$indent}      <tr>\\n";

                // Pro cell
                $html .= "{$indent}        <td class=\\"pro-cell\\">\\n";
                if (isset($supporting[$i])) {
                    $html .= self::renderTree($supporting[$i]->id, $depth + 3);
                }
                $html .= "{$indent}        </td>\\n";

                // Con cell
                $html .= "{$indent}        <td class=\\"con-cell\\">\\n";
                if (isset($weakening[$i])) {
                    $html .= self::renderTree($weakening[$i]->id, $depth + 3);
                }
                $html .= "{$indent}        </td>\\n";

                $html .= "{$indent}      </tr>\\n";
            }

            $html .= "{$indent}    </tbody>\\n";
            $html .= "{$indent}  </table>\\n";
        }

        $html .= "{$indent}</div>\\n";

        return $html;
    }

    /**
     * Get CSS class based on score level.
     */
    private static function getScoreClass(float $score): string {
        if ($score >= 0.75) return 'score-high';
        if ($score >= 0.50) return 'score-moderate';
        if ($score >= 0.25) return 'score-low';
        return 'score-very-low';
    }
}
"""

    def _generate_belief_tree_page(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - Belief Tree Page
 *
 * Renders a complete belief argument tree with Pro/Con columns.
 * Scores are pulled from MySQL and computed in real time.
 */

require_once __DIR__ . '/ArgumentTree.php';
require_once __DIR__ . '/ReasonRank.php';

// Get the belief ID from the URL
$beliefId = $_GET['id'] ?? null;

if ($beliefId === null) {
    // Show the leaderboard of all root beliefs
    $roots = BeliefNode::getRoots();
} else {
    $belief = BeliefNode::findById($beliefId);
    if ($belief === null) {
        http_response_code(404);
        echo "Belief not found.";
        exit;
    }
}
?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ISE Belief Analysis<?= isset($belief) ? ' - ' . htmlspecialchars($belief->statement) : '' ?></title>
  <style>
    :root {
      --ise-pro: #e8f5e9;
      --ise-con: #ffebee;
      --ise-pro-border: #4caf50;
      --ise-con-border: #f44336;
      --ise-score-high: #2e7d32;
      --ise-score-moderate: #f57f17;
      --ise-score-low: #e65100;
      --ise-score-very-low: #b71c1c;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #fafafa;
    }

    h1 { margin-bottom: 20px; color: #1a237e; }

    .belief-node {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .belief-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .belief-statement { font-weight: 600; flex: 1; }

    .belief-score {
      font-family: monospace;
      font-size: 0.9em;
      padding: 2px 8px;
      border-radius: 4px;
      background: #e3f2fd;
      margin-left: 12px;
      white-space: nowrap;
    }

    .score-breakdown {
      display: flex;
      gap: 12px;
      font-size: 0.8em;
      color: #666;
      margin-bottom: 8px;
    }

    .metric {
      padding: 1px 6px;
      border-radius: 3px;
      background: #f5f5f5;
      font-family: monospace;
    }

    .linkage-score { cursor: help; }

    .linkage-type {
      font-size: 0.65em;
      vertical-align: super;
      color: #555;
      font-style: normal;
    }

    .depth-badge {
      background: #e8eaf6;
      color: #3949ab;
      font-size: 0.8em;
    }

    .pro-con-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }

    .pro-header {
      background: var(--ise-pro);
      color: var(--ise-pro-border);
      padding: 8px;
      font-weight: 600;
      border-bottom: 2px solid var(--ise-pro-border);
      width: 50%;
    }

    .con-header {
      background: var(--ise-con);
      color: var(--ise-con-border);
      padding: 8px;
      font-weight: 600;
      border-bottom: 2px solid var(--ise-con-border);
      width: 50%;
    }

    .pro-cell {
      vertical-align: top;
      padding: 4px;
      border-left: 3px solid var(--ise-pro-border);
      background: var(--ise-pro);
    }

    .con-cell {
      vertical-align: top;
      padding: 4px;
      border-left: 3px solid var(--ise-con-border);
      background: var(--ise-con);
    }

    .score-high .belief-score { background: var(--ise-score-high); color: white; }
    .score-moderate .belief-score { background: var(--ise-score-moderate); color: white; }
    .score-low .belief-score { background: var(--ise-score-low); color: white; }
    .score-very-low .belief-score { background: var(--ise-score-very-low); color: white; }

    /* Leaderboard styles */
    .leaderboard { list-style: none; padding: 0; }
    .leaderboard li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      margin: 4px 0;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #1a237e;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .leaderboard li:hover { background: #e8eaf6; }
    .leaderboard a { text-decoration: none; color: #1a237e; font-weight: 600; }
    .rank-number {
      font-size: 1.2em;
      font-weight: 700;
      color: #666;
      margin-right: 16px;
      min-width: 30px;
    }
  </style>
</head>
<body>

<?php if ($beliefId === null): ?>
  <h1>ISE Belief Leaderboard</h1>
  <p>All root beliefs ranked by ReasonRank score. Best-supported reasoning is at the top.</p>
  <ol class="leaderboard">
    <?php foreach ($roots as $i => $root): ?>
      <li>
        <span class="rank-number">#<?= $i + 1 ?></span>
        <a href="?id=<?= urlencode($root->id) ?>">
          <?= htmlspecialchars($root->statement) ?>
        </a>
        <span class="belief-score"><?= number_format($root->propagatedScore, 4) ?></span>
      </li>
    <?php endforeach; ?>
  </ol>

<?php else: ?>
  <h1><?= htmlspecialchars($belief->statement) ?></h1>
  <p><a href="?">&larr; Back to Leaderboard</a></p>
  <?= ArgumentTree::renderTree($beliefId) ?>
<?php endif; ?>

</body>
</html>
"""

    def _generate_api(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - REST API
 *
 * Endpoints:
 *   GET  /api.php?action=tree&id=X     - Get belief tree as JSON
 *   GET  /api.php?action=roots          - Get all root beliefs
 *   POST /api.php?action=add            - Add a new belief node
 *   POST /api.php?action=update         - Update a belief node's scores
 *   POST /api.php?action=recalculate    - Trigger full recalculation
 */

require_once __DIR__ . '/BeliefNode.php';
require_once __DIR__ . '/ReasonRank.php';

header('Content-Type: application/json');

$action = $_GET['action'] ?? $_POST['action'] ?? '';

try {
    switch ($action) {
        case 'roots':
            $roots = BeliefNode::getRoots();
            echo json_encode([
                'success' => true,
                'data' => array_map(fn($n) => nodeToArray($n), $roots),
            ]);
            break;

        case 'tree':
            $id = $_GET['id'] ?? '';
            if (empty($id)) {
                throw new Exception('Missing id parameter');
            }
            $tree = buildTreeArray($id);
            echo json_encode(['success' => true, 'data' => $tree]);
            break;

        case 'add':
            $input = json_decode(file_get_contents('php://input'), true);
            if (!$input) {
                throw new Exception('Invalid JSON input');
            }

            $node = new BeliefNode();
            $node->id = $input['id'] ?? uniqid('node_');
            $node->statement = $input['statement'] ?? '';
            $node->category = $input['category'] ?? '';
            $node->subcategory = $input['subcategory'] ?? '';
            $node->parentId = $input['parent_id'] ?? null;
            $node->side = $input['side'] ?? 'supporting';
            $node->truthScore = (float)($input['truth_score'] ?? 0.5);
            $node->linkageScore = (float)($input['linkage_score'] ?? 0.5);
            $node->linkageScoreType = in_array($input['linkage_score_type'] ?? '', ['ECLS', 'ACLS'])
                ? $input['linkage_score_type']
                : ($node->parentId === null ? 'ECLS' : 'ACLS');
            $node->depth = (int)($input['depth'] ?? 0);
            $node->importanceScore = (float)($input['importance_score'] ?? 0.5);
            $node->uniquenessScore = (float)($input['uniqueness_score'] ?? 1.0);
            $node->sourceUrl = $input['source_url'] ?? '';
            $node->evidenceType = $input['evidence_type'] ?? 'T3';
            $node->reasonRank = $node->computeBaseRank();
            $node->propagatedScore = $node->reasonRank;

            $node->insert();

            // Trigger re-sort of parent's children
            if ($node->parentId !== null) {
                ReasonRank::recalculateNode($node->parentId);
            }

            echo json_encode(['success' => true, 'data' => nodeToArray($node)]);
            break;

        case 'update':
            $input = json_decode(file_get_contents('php://input'), true);
            if (!$input || empty($input['id'])) {
                throw new Exception('Invalid input or missing id');
            }

            $node = BeliefNode::findById($input['id']);
            if ($node === null) {
                throw new Exception('Node not found');
            }

            // Update allowed fields
            if (isset($input['truth_score'])) $node->truthScore = (float)$input['truth_score'];
            if (isset($input['linkage_score'])) $node->linkageScore = (float)$input['linkage_score'];
            if (isset($input['importance_score'])) $node->importanceScore = (float)$input['importance_score'];
            if (isset($input['uniqueness_score'])) $node->uniquenessScore = (float)$input['uniqueness_score'];

            $node->save();

            // Trigger automatic re-sort
            ReasonRank::recalculateNode($node->id);

            echo json_encode(['success' => true, 'data' => nodeToArray($node)]);
            break;

        case 'recalculate':
            ReasonRank::recalculateAll();
            echo json_encode(['success' => true, 'message' => 'All scores recalculated']);
            break;

        default:
            throw new Exception("Unknown action: {$action}");
    }
} catch (Exception $e) {
    http_response_code(400);
    echo json_encode(['success' => false, 'error' => $e->getMessage()]);
}


/**
 * Convert a BeliefNode to an array for JSON output.
 */
function nodeToArray(BeliefNode $node): array {
    return [
        'id' => $node->id,
        'statement' => $node->statement,
        'category' => $node->category,
        'subcategory' => $node->subcategory,
        'parent_id' => $node->parentId,
        'side' => $node->side,
        'truth_score' => $node->truthScore,
        'linkage_score' => $node->linkageScore,
        'linkage_score_type' => $node->linkageScoreType,
        'attenuated_linkage_score' => $node->attenuatedLinkageScore(),
        'depth' => $node->depth,
        'importance_score' => $node->importanceScore,
        'uniqueness_score' => $node->uniquenessScore,
        'reason_rank' => $node->reasonRank,
        'propagated_score' => $node->propagatedScore,
        'source_url' => $node->sourceUrl,
        'evidence_type' => $node->evidenceType,
    ];
}

/**
 * Build a nested tree array for JSON output.
 */
function buildTreeArray(string $nodeId): ?array {
    $node = BeliefNode::findById($nodeId);
    if ($node === null) return null;

    $result = nodeToArray($node);
    $breakdown = ReasonRank::getScoreBreakdown($nodeId);
    $result['breakdown'] = $breakdown;

    $supporting = BeliefNode::getSupportingChildren($nodeId);
    $weakening = BeliefNode::getWeakeningChildren($nodeId);

    $result['supporting'] = array_map(fn($c) => buildTreeArray($c->id), $supporting);
    $result['weakening'] = array_map(fn($c) => buildTreeArray($c->id), $weakening);

    return $result;
}
"""

    def _generate_index(self) -> str:
        return """\
<?php
/**
 * ISE Justification Pipeline - Entry Point
 *
 * Routes requests to the appropriate handler.
 */

$requestUri = $_SERVER['REQUEST_URI'] ?? '/';
$path = parse_url($requestUri, PHP_URL_PATH);

if (strpos($path, '/api') === 0 || isset($_GET['action'])) {
    require_once __DIR__ . '/api.php';
} else {
    require_once __DIR__ . '/belief_tree.php';
}
"""
