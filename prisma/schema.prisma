generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// Core belief - each belief gets its own page
model Belief {
  id          Int      @id @default(autoincrement())
  slug        String   @unique
  statement   String   // The belief statement
  category    String?  // Topic category
  subcategory String?  // Topic subcategory
  deweyNumber String?  // Dewey classification
  positivity  Float    @default(0) // -100 to +100

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Arguments where this belief IS the reason (child)
  asArgument Argument[] @relation("ArgumentBelief")

  // Arguments attached TO this belief (parent)
  arguments Argument[] @relation("ParentBelief")

  // Evidence attached to this belief
  evidence Evidence[]

  // Objective criteria for this belief
  objectiveCriteria ObjectiveCriteria[]

  // Values analysis
  valuesAnalysis ValuesAnalysis?

  // Interests analysis
  interestsAnalysis InterestsAnalysis?

  // Assumptions
  assumptions Assumption[]

  // Cost-benefit analysis
  costBenefitAnalysis CostBenefitAnalysis?

  // Short vs long term impacts
  impactAnalysis ImpactAnalysis?

  // Compromise solutions
  compromises Compromise[]

  // Obstacles to resolution
  obstacles Obstacle[]

  // Biases
  biases BiasEntry[]

  // Media resources
  mediaResources MediaResource[]

  // Legal framework
  legalEntries LegalEntry[]

  // Belief mapping (general to specific)
  upstreamMappings   BeliefMapping[] @relation("MappingChild")
  downstreamMappings BeliefMapping[] @relation("MappingParent")

  // Similar beliefs
  similarTo      SimilarBelief[] @relation("SimilarFrom")
  similarFrom    SimilarBelief[] @relation("SimilarTo")
}

// An argument linking one belief (reason) to another belief (conclusion)
// Each reason is itself a belief with its own page
model Argument {
  id Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("ParentBelief", fields: [parentBeliefId], references: [id])

  // The reason (which is itself a belief with its own page)
  beliefId Int
  belief   Belief @relation("ArgumentBelief", fields: [beliefId], references: [id])

  side         String // "agree" or "disagree"
  linkageScore Float  @default(0.5) // 0 to 1
  impactScore  Float  @default(0)   // computed
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
// Prisma schema for IdeaStockExchange
// A comprehensive debate platform with integrated media lists and social features

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core Book Model
model Book {
  id          String   @id @default(cuid())
  title       String
  author      String
  isbn        String?  @unique
  publishYear Int?
  description String?  @db.Text
  coverImage  String?

  // Four-Dimensional Scoring Framework
  logicalValidityScore Float @default(0) // 0-100
  qualityScore         Float @default(0) // 0-100
  beliefImpactWeight   Float @default(0) // Influence multiplier (log of reach)

  // Reach metrics for Belief Impact calculation
  salesCount      Int @default(0)
  citationCount   Int @default(0)
  socialShares    Int @default(0)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  claims         Claim[]
  topicOverlaps  TopicOverlap[]
  fallacies      Fallacy[]
  contradictions Contradiction[]
  evidenceItems  Evidence[]
  metaphors      Metaphor[]
  predictions    Prediction[]
  authorProfile  Author? @relation(fields: [authorId], references: [id])
  authorId       String?

  @@index([title])
  @@index([author])
}

// Individual testable claims within a book
model Claim {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  content        String   @db.Text
  pageNumber     Int?
  chapterNumber  Int?

  // Centrality weighting (0.1 to 1.0)
  centralityWeight Float @default(0.5)
  centralityType   String @default("supporting") // "thesis", "major", "supporting", "example", "tangential", "footnote"

  // Validity score for this specific claim
  validityScore  Float @default(50) // 0-100

  // AI + Crowd scoring
  aiConfidence   Float @default(0) // 0-1
  crowdConsensus Float @default(0) // 0-1
  expertWeighting Float @default(0) // 0-1

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fallacies      Fallacy[]
  evidenceLinks  Evidence[]

  @@index([bookId])
}

// Topic Overlap Scores (how central a belief is to the book)
model TopicOverlap {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  topicName      String   // e.g., "Revenge", "Mortality", "Cognitive Biases"
  overlapScore   Float    // 0-100%
  pagesDevoted   Int?
  argumentDensity Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([bookId, topicName])
  @@index([topicName])
}

// Logic Battleground 1: Fallacy Autopsy Theater
model Fallacy {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  claimId        String?
  claim          Claim?   @relation(fields: [claimId], references: [id], onDelete: Cascade)

  fallacyType    String   // "ad_hominem", "strawman", "slippery_slope", "post_hoc", "false_equivalence", etc.
  description    String   @db.Text
  quote          String?  @db.Text
  pageNumber     Int?

  // Scoring
  flaggedBy      String   // "ai" or "crowd" or "expert"
  confidence     Float    @default(0.5) // 0-1
  debateConsensus Float?  // After crowd debate

  impactOnValidity Float @default(-10) // Percentage impact on overall score

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookId])
  @@index([fallacyType])
}

// Logic Battleground 2: Contradiction Trials
model Contradiction {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  claim1         String   @db.Text
  claim1Page     Int?
  claim2         String   @db.Text
  claim2Page     Int?

  contradictionType String // "direct", "implicit", "context_dependent"
  severity       Float    @default(0.5) // 0-1

  // Crowd validation
  validatedBy    Int      @default(0) // Number of users who confirmed
  disputedBy     Int      @default(0) // Number who disputed

  impactOnIntegrity Float @default(-8) // Percentage impact

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Linkage arguments - reasons to agree/disagree with the linkage itself
  linkageArguments LinkageArgument[]
}

// Arguments about whether a linkage between two beliefs is valid
model LinkageArgument {
  id         Int      @id @default(autoincrement())
  argumentId Int
  argument   Argument @relation(fields: [argumentId], references: [id])
  side       String   // "agree" or "disagree" with the linkage
  statement  String
  strength   Float    @default(0.5)
  createdAt  DateTime @default(now())
}

// Evidence supporting or weakening a belief
model Evidence {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "weakening"
  description String
  sourceUrl   String?
  evidenceType String @default("T3") // T1=Peer-reviewed, T2=Expert, T3=Journalism, T4=Opinion

  // Evidence Verification Score components
  sourceIndependenceWeight Float @default(0.5) // ESIW
  replicationQuantity      Int   @default(1)   // ERQ
  conclusionRelevance      Float @default(0.5) // ECRS
  replicationPercentage    Float @default(1.0) // ERP

  linkageScore Float @default(0.5)
  impactScore  Float @default(0) // computed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Objective criteria for measuring belief strength
model ObjectiveCriteria {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description      String
  independenceScore Float @default(0.5)
  linkageScore     Float @default(0.5)
  criteriaType     String? // e.g. "market value", "scientific judgment", "precedent"
  totalScore       Float  @default(0) // computed

  createdAt DateTime @default(now())
}

// Core values conflict analysis
model ValuesAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supportingAdvertised String? // What supporters claim
  supportingActual     String? // What actually motivates supporters
  opposingAdvertised   String? // What opponents claim
  opposingActual       String? // What actually motivates opponents

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Interests & motivations analysis
model InterestsAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supporterInterests   String? // Numbered list
  opponentInterests    String? // Numbered list
  sharedInterests      String? // Numbered list
  conflictingInterests String? // Numbered list

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Foundational assumptions
model Assumption {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "accept" or "reject"
  statement  String
  strength   String @default("MODERATE") // CRITICAL, STRONG, MODERATE, WEAK

  createdAt DateTime @default(now())
}

// Cost-benefit analysis
model CostBenefitAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  benefits          String? // improvements, who gains, positive externalities
  benefitLikelihood Float?
  costs             String? // problems, who loses, negative externalities
  costLikelihood    Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Short vs long-term impact analysis
model ImpactAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  shortTermEffects    String? // 0-2 years
  shortTermCosts      String? // transition costs
  longTermEffects     String? // 5+ years
  longTermChanges     String? // structural changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Compromise solutions
model Compromise {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description String
  createdAt   DateTime @default(now())
}

// Obstacles to resolution
model Obstacle {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporter" or "opposition"
  description String
  createdAt   DateTime @default(now())
}

// Bias entries
model BiasEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side     String // "supporter" or "opponent"
  biasType String // CONFIRMATION_BIAS, ANCHORING, etc.
  description String?

  createdAt DateTime @default(now())
}

// Media resources
model MediaResource {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "supporting" or "opposing"
  mediaType  String // "book", "article", "podcast", "movie", "song"
  title      String
  author     String?
  url        String?

  createdAt DateTime @default(now())
}

// Legal framework
model LegalEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "contradicting"
  description String
  jurisdiction String? // "local", "state", "federal", "international"

  createdAt DateTime @default(now())
}

// General to specific belief mapping
model BeliefMapping {
  id       Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("MappingParent", fields: [parentBeliefId], references: [id])

  childBeliefId Int
  childBelief   Belief @relation("MappingChild", fields: [childBeliefId], references: [id])

  direction String // "upstream" (more general) or "downstream" (more specific)
  side      String // "support" or "oppose"

  createdAt DateTime @default(now())
}

// Similar beliefs
model SimilarBelief {
  id Int @id @default(autoincrement())

  fromBeliefId Int
  fromBelief   Belief @relation("SimilarFrom", fields: [fromBeliefId], references: [id])

  toBeliefId Int
  toBelief   Belief @relation("SimilarTo", fields: [toBeliefId], references: [id])

  variant String // "extreme" or "moderate"

  createdAt DateTime @default(now())
  @@index([bookId])
}

// Logic Battleground 3: Evidence War Rooms
model Evidence {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  claimId        String?
  claim          Claim?   @relation(fields: [claimId], references: [id], onDelete: Cascade)

  evidenceType   String   // "peer_reviewed", "statistical", "anecdotal", "speculation"
  description    String   @db.Text
  sourceUrl      String?

  // Quality assessment
  qualityTier    String   // "tier1_peer_reviewed", "tier2_statistical", "tier3_anecdotal", "tier4_speculation"
  replicationStatus String? // "replicated", "failed_replication", "not_tested"

  validityScore  Float    @default(50) // 0-100

  // Time decay for outdated claims
  publishedDate  DateTime?
  lastVerified   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookId])
  @@index([evidenceType])
}

// Logic Battleground 4: Metaphor MRI Scans
model Metaphor {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  metaphorText   String   @db.Text
  pageNumber     Int?

  targetConcept  String   // What's being explained
  sourceConcept  String   // What it's compared to

  // Accuracy assessment
  structuralSimilarity Float @default(0.5) // 0-1
  clarityScore   Float    @default(0.5) // Does it clarify or confuse?

  isMisleading   Boolean  @default(false)
  impactOnValidity Float  @default(0) // Can be positive or negative

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookId])
}

// Logic Battleground 5: Prediction Mortuaries
model Prediction {
  id             String   @id @default(cuid())
  bookId         String
  book           Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  predictionText String   @db.Text
  targetDate     DateTime? // When prediction should be evaluated
  pageNumber     Int?

  // Outcome tracking
  actualOutcome  String?  @db.Text
  accuracyScore  Float?   // 0-100, evaluated after target date

  status         String   @default("pending") // "pending", "verified", "failed", "partially_correct"

  impactOnCredibility Float @default(0) // Affects author's overall credibility

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  evaluatedAt DateTime?

  @@index([bookId])
  @@index([targetDate])
  @@index([status])
}

// Author profile with Truth Equity tracking
model Author {
  id             String   @id @default(cuid())
  name           String   @unique
  bio            String?  @db.Text

  // Truth Equity: historical accuracy across all works
  truthEquityScore Float @default(50) // 0-100
  totalBooks       Int    @default(0)
  avgBookValidity  Float  @default(0)

  // Prediction track record
  totalPredictions    Int   @default(0)
  accuratePredictions Int   @default(0)

  books          Book[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

// User contributions for crowd validation
model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?

  // Credibility multiplier (top contributors get higher weight)
  credibilityScore Float @default(1.0) // 1.0 to 10.0
  accuracyRate     Float @default(0.5) // 0-1

  contributionCount Int  @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  username      String   @unique
  passwordHash  String
  bio           String?
  avatarUrl     String?
  website       String?
  location      String?

  // Status
  isVerified    Boolean  @default(false)
  isModerator   Boolean  @default(false)
  isAdmin       Boolean  @default(false)
  isBanned      Boolean  @default(false)
  bannedUntil   DateTime?

  // Reputation & Stats
  karma         Int      @default(0)
  reputation    Int      @default(0)

  // Privacy
  emailVisible  Boolean  @default(false)
  profilePublic Boolean  @default(true)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastSeenAt    DateTime @default(now())

  // Relations - Content
  debates              Debate[]
  arguments            Argument[]
  media                Media[]
  comments             Comment[]
  drafts               Draft[]

  // Relations - Engagement
  votes                Vote[]
  commentVotes         CommentVote[]
  follows              Follow[]        @relation("Follower")
  followers            Follow[]        @relation("Following")
  debateSubscriptions  DebateSubscription[]

  // Relations - Social
  sentMessages         DirectMessage[] @relation("Sender")
  receivedMessages     DirectMessage[] @relation("Recipient")
  blockedUsers         UserBlock[]     @relation("Blocker")
  blockedBy            UserBlock[]     @relation("Blocked")

  // Relations - Moderation
  reports              Report[]
  moderationActions    ModerationAction[]
  receivedActions      ModerationAction[] @relation("Target")

  // Relations - Merging
  mergeProposals       MergeProposal[]
  mergeVotes           MergeVote[]

  // Relations - Education
  ownedClassrooms      Classroom[]     @relation("Teacher")
  enrolledClassrooms   ClassroomStudent[]
  assignments          Assignment[]
  submissions          Submission[]

  // Relations - Templates
  templates            Template[]

  // Relations - Achievements
  achievements         UserAchievement[]

  // Relations - Notifications
  notifications        Notification[]

  // Relations - Edit History
  edits                EditHistory[]

  @@map("users")
}

// User statistics (for analytics and leaderboards)
model UserStats {
  id                String   @id @default(cuid())
  userId            String   @unique

  // Counts
  debatesCreated    Int      @default(0)
  argumentsPosted   Int      @default(0)
  commentsPosted    Int      @default(0)
  mediaAdded        Int      @default(0)

  // Engagement
  upvotesReceived   Int      @default(0)
  downvotesReceived Int      @default(0)
  upvotesGiven      Int      @default(0)
  downvotesGiven    Int      @default(0)

  // Quality metrics
  avgTruthScore     Float?
  avgImportanceScore Float?
  avgRelevanceScore Float?

  updatedAt         DateTime @updatedAt

  @@map("user_stats")
}

// Follow relationships (users following users)
model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User     @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

// User blocking
model UserBlock {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())

  blocker   User     @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("user_blocks")
}

// ============================================================================
// DEBATES
// ============================================================================

model Debate {
  id            String   @id @default(cuid())
  title         String
  description   String?
  thesis        String?  // Main claim to be debated

  // Metadata
  isPublic      Boolean  @default(true)
  tags          String[]
  category      String?

  // Settings
  allowComments Boolean  @default(true)
  requireModeration Boolean @default(false)
  isLocked      Boolean  @default(false)
  isFeatured    Boolean  @default(false)

  // Template
  isTemplate    Boolean  @default(false)
  templateId    String?

  // Stats
  viewCount     Int      @default(0)
  participantCount Int   @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  authorId      String

  // Relations
  author        User     @relation(fields: [authorId], references: [id])
  arguments     Argument[]
  subscriptions DebateSubscription[]
  template      Template? @relation(fields: [templateId], references: [id])
  classroomDebates ClassroomDebate[]
  editHistory   EditHistory[] @relation("DebateEdits")

  @@map("debates")
}

// Debate subscriptions (users following debates)
model DebateSubscription {
  id          String   @id @default(cuid())
  userId      String
  debateId    String

  // Notification preferences
  notifyOnArgument Boolean @default(true)
  notifyOnComment  Boolean @default(true)
  notifyOnMerge    Boolean @default(false)

  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  @@unique([userId, debateId])
  @@map("debate_subscriptions")
}

// ============================================================================
// ARGUMENTS
// ============================================================================

model Argument {
  id            String   @id @default(cuid())
  content       String
  summary       String?  // Short summary for overview mode

  // Position in debate
  debateId      String
  parentId      String?
  authorId      String
  position      ArgumentPosition @default(NEUTRAL)

  // Status
  status        ArgumentStatus @default(PUBLISHED)
  isDraft       Boolean  @default(false)
  isDeleted     Boolean  @default(false)
  deletedAt     DateTime?

  // Scoring
  truthScore        Float?
  importanceScore   Float?
  relevanceScore    Float?
  reasonRank        Float?
  impactScore       Float?  // Kialo-style impact rating

  // Stats
  viewCount         Int      @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  debate        Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)
  parent        Argument? @relation("ArgumentHierarchy", fields: [parentId], references: [id])
  children      Argument[] @relation("ArgumentHierarchy")
  author        User     @relation(fields: [authorId], references: [id])
  media         ArgumentMedia[]
  votes         Vote[]
  comments      Comment[]

  // Merging
  mergeProposalsSource MergeProposal[] @relation("SourceArgument")
  mergeProposalsTarget MergeProposal[] @relation("TargetArgument")
  mergedFrom    ArgumentMerge[] @relation("MergedFrom")
  mergedInto    ArgumentMerge[] @relation("MergedInto")

  // Reports and moderation
  reports       Report[]
  moderationActions ModerationAction[] @relation("ArgumentActions")

  // Edit history
  editHistory   EditHistory[] @relation("ArgumentEdits")

  // Suggestions
  suggestedEdits SuggestedEdit[]

  @@map("arguments")
}

enum ArgumentPosition {
  PRO
  CON
  NEUTRAL
}

enum ArgumentStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  ARCHIVED
  MERGED
}

// ============================================================================
// COMMENTS (Discussion Threads)
// ============================================================================

model Comment {
  id          String   @id @default(cuid())
  content     String
  argumentId  String
  authorId    String
  parentId    String?  // For nested comments

  // Status
  isDeleted   Boolean  @default(false)
  isEdited    Boolean  @default(false)
  deletedAt   DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  author      User     @relation(fields: [authorId], references: [id])
  parent      Comment? @relation("CommentHierarchy", fields: [parentId], references: [id])
  children    Comment[] @relation("CommentHierarchy")
  votes       CommentVote[]
  reports     Report[]

  @@map("comments")
}

model CommentVote {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  voteType  VoteType
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("comment_votes")
}

// ============================================================================
// VOTES
// ============================================================================

model Vote {
  id          String   @id @default(cuid())
  userId      String
  argumentId  String
  voteType    VoteType
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])
  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([userId, argumentId])
  @@map("votes")
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

// ============================================================================
// MEDIA
// ============================================================================

model Media {
  id            String   @id @default(cuid())
  title         String
  description   String?
  url           String?
  mediaType     MediaType

  // Metadata
  thumbnailUrl  String?
  author        String?
  publishDate   DateTime?
  isbn          String?
  duration      Int?

  // Source credibility
  sourceUrl     String?
  credibilityScore Float?
  biasScore     Float?

  // Status
  isVerified    Boolean  @default(false)
  verifiedBy    String?
  verifiedAt    DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  authorId      String

  // Relations
  creator       User     @relation(fields: [authorId], references: [id])
  arguments     ArgumentMedia[]
  reports       Report[]

  @@map("media")
}

enum MediaType {
  BOOK
  VIDEO
  ARTICLE
  IMAGE
  PODCAST
  DOCUMENTARY
  PAPER
  WEBSITE
}

model ArgumentMedia {
  id          String   @id @default(cuid())
  argumentId  String
  mediaId     String
  position    MediaPosition
  relevance   Float?
  createdAt   DateTime @default(now())

  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  media       Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@unique([argumentId, mediaId])
  @@map("argument_media")
}

enum MediaPosition {
  SUPPORTS
  REFUTES
  NEUTRAL
}

// ============================================================================
// ARGUMENT MERGING
// ============================================================================

model MergeProposal {
  id              String   @id @default(cuid())
  sourceArgumentId String
  targetArgumentId String
  proposerId      String

  reason          String
  status          MergeStatus @default(PENDING)

  createdAt       DateTime @default(now())
  resolvedAt      DateTime?
  resolvedBy      String?

  // Relations
  sourceArgument  Argument @relation("SourceArgument", fields: [sourceArgumentId], references: [id], onDelete: Cascade)
  targetArgument  Argument @relation("TargetArgument", fields: [targetArgumentId], references: [id], onDelete: Cascade)
  proposer        User     @relation(fields: [proposerId], references: [id])
  votes           MergeVote[]

  @@map("merge_proposals")
}

model MergeVote {
  id          String   @id @default(cuid())
  proposalId  String
  userId      String
  approve     Boolean
  createdAt   DateTime @default(now())

  proposal    MergeProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id])

  @@unique([proposalId, userId])
  @@map("merge_votes")
}

model ArgumentMerge {
  id          String   @id @default(cuid())
  fromId      String
  intoId      String
  mergedBy    String
  mergedAt    DateTime @default(now())

  from        Argument @relation("MergedFrom", fields: [fromId], references: [id])
  into        Argument @relation("MergedInto", fields: [intoId], references: [id])

  @@map("argument_merges")
}

enum MergeStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

// ============================================================================
// SUGGESTED EDITS
// ============================================================================

model SuggestedEdit {
  id          String   @id @default(cuid())
  argumentId  String
  suggesterId String

  originalContent String
  suggestedContent String
  reason      String?

  status      SuggestedEditStatus @default(PENDING)

  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@map("suggested_edits")
}

enum SuggestedEditStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// ============================================================================
// DRAFTS (Auto-save)
// ============================================================================

model Draft {
  id          String   @id @default(cuid())
  userId      String

  // Content
  type        DraftType
  title       String?
  content     String

  // Context
  debateId    String?
  argumentId  String?  // Parent argument if replying
  position    ArgumentPosition?

  // Metadata
  autoSaved   Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("drafts")
}

enum DraftType {
  DEBATE
  ARGUMENT
  COMMENT
  MEDIA
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

model Notification {
  id          String   @id @default(cuid())
  userId      String

  type        NotificationType
  title       String
  message     String

  // Context
  debateId    String?
  argumentId  String?
  commentId   String?
  fromUserId  String?

  // Status
  isRead      Boolean  @default(false)
  readAt      DateTime?

  // Links
  actionUrl   String?

  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

enum NotificationType {
  NEW_ARGUMENT
  NEW_COMMENT
  NEW_REPLY
  VOTE_RECEIVED
  MENTION
  FOLLOW
  MERGE_PROPOSAL
  MERGE_APPROVED
  REPORT_RESOLVED
  MODERATION_ACTION
  ASSIGNMENT_CREATED
  ASSIGNMENT_GRADED
  MESSAGE_RECEIVED
}

// ============================================================================
// DIRECT MESSAGES
// ============================================================================

model DirectMessage {
  id          String   @id @default(cuid())
  senderId    String
  recipientId String

  content     String

  isRead      Boolean  @default(false)
  readAt      DateTime?

  isDeleted   Boolean  @default(false)
  deletedBy   String?

  createdAt   DateTime @default(now())

  sender      User     @relation("Sender", fields: [senderId], references: [id])
  recipient   User     @relation("Recipient", fields: [recipientId], references: [id])

  @@map("direct_messages")
}

// ============================================================================
// MODERATION
// ============================================================================

model Report {
  id          String   @id @default(cuid())
  reporterId  String

  // What's being reported
  targetType  ReportTargetType
  argumentId  String?
  commentId   String?
  mediaId     String?
  userId      String?  // Reporting a user

  reason      ReportReason
  description String?

  status      ReportStatus @default(PENDING)

  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?
  resolution  String?

  reporter    User     @relation(fields: [reporterId], references: [id])
  argument    Argument? @relation(fields: [argumentId], references: [id])
  comment     Comment?  @relation(fields: [commentId], references: [id])
  media       Media?    @relation(fields: [mediaId], references: [id])

  @@map("reports")
}

enum ReportTargetType {
  ARGUMENT
  COMMENT
  MEDIA
  USER
  DEBATE
}

enum ReportReason {
  SPAM
  HARASSMENT
  MISINFORMATION
  OFF_TOPIC
  INAPPROPRIATE
  DUPLICATE
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

model ModerationAction {
  id          String   @id @default(cuid())
  moderatorId String
  targetUserId String?

  // What was moderated
  targetType  ModerationTargetType
  argumentId  String?
  commentId   String?
  debateId    String?

  action      ModerationType
  reason      String
  duration    Int?     // Duration in hours for temp bans

  createdAt   DateTime @default(now())
  expiresAt   DateTime?

  moderator   User     @relation(fields: [moderatorId], references: [id])
  targetUser  User?    @relation("Target", fields: [targetUserId], references: [id])
  argument    Argument? @relation("ArgumentActions", fields: [argumentId], references: [id])

  @@map("moderation_actions")
}

enum ModerationTargetType {
  ARGUMENT
  COMMENT
  DEBATE
  USER
  MEDIA
}

enum ModerationType {
  DELETE
  HIDE
  LOCK
  BAN_USER
  TEMP_BAN
  MUTE
  WARNING
  APPROVE
  FEATURE
}

// ============================================================================
// TEMPLATES
// ============================================================================

model Template {
  id          String   @id @default(cuid())
  name        String
  description String?

  // Template structure
  thesisTemplate String
  categories  String[]
  tags        String[]

  // Predefined arguments
  structure   Json?    // JSON structure of initial arguments

  // Settings
  isPublic    Boolean  @default(true)
  usageCount  Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  creatorId   String

  creator     User     @relation(fields: [creatorId], references: [id])
  debates     Debate[]

  @@map("templates")
}

// ============================================================================
// EDUCATION / CLASSROOMS
// ============================================================================

model Classroom {
  id          String   @id @default(cuid())
  name        String
  description String?

  code        String   @unique  // Join code

  isActive    Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  teacherId   String

  teacher     User     @relation("Teacher", fields: [teacherId], references: [id])
  students    ClassroomStudent[]
  debates     ClassroomDebate[]
  assignments Assignment[]

  @@map("classrooms")
}

model ClassroomStudent {
  id          String   @id @default(cuid())
  classroomId String
  studentId   String

  enrolledAt  DateTime @default(now())
  isActive    Boolean  @default(true)

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)

  @@unique([classroomId, studentId])
  @@map("classroom_students")
}

model ClassroomDebate {
  id          String   @id @default(cuid())
  classroomId String
  debateId    String

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  @@unique([classroomId, debateId])
  @@map("classroom_debates")
}

model Assignment {
  id          String   @id @default(cuid())
  classroomId String
  teacherId   String

  title       String
  description String?
  instructions String?

  // Requirements
  debateId    String?
  minArguments Int?
  minMediaSources Int?

  // Grading
  totalPoints Int      @default(100)

  // Dates
  dueDate     DateTime
  createdAt   DateTime @default(now())

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
  teacher     User     @relation(fields: [teacherId], references: [id])
  submissions Submission[]

  @@map("assignments")
}

model Submission {
  id          String   @id @default(cuid())
  assignmentId String
  studentId   String

  // Content
  content     String?
  argumentIds String[] // Arguments submitted

  // Grading
  status      SubmissionStatus @default(PENDING)
  grade       Float?
  maxGrade    Float?
  feedback    String?

  submittedAt DateTime @default(now())
  gradedAt    DateTime?

  assignment  Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  student     User     @relation(fields: [studentId], references: [id])

  @@unique([assignmentId, studentId])
  @@map("submissions")
}

enum SubmissionStatus {
  PENDING
  SUBMITTED
  GRADED
  LATE
}

// ============================================================================
// ACHIEVEMENTS & GAMIFICATION
// ============================================================================

model Achievement {
  id          String   @id @default(cuid())
  name        String
  description String
  icon        String?

  // Criteria
  type        AchievementType
  threshold   Int      // e.g., 10 debates, 100 karma, etc.

  // Rewards
  karmaReward Int      @default(0)

  createdAt   DateTime @default(now())

  users       UserAchievement[]

  @@map("achievements")
}

enum AchievementType {
  DEBATES_CREATED
  ARGUMENTS_POSTED
  KARMA_EARNED
  MEDIA_CONTRIBUTED
  VOTES_RECEIVED
  STREAK_DAYS
  MODERATOR_ACTIONS
  HELPFUL_VOTES
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String

  unlockedAt    DateTime @default(now())
  progress      Int      @default(0)

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id])

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// ============================================================================
// EDIT HISTORY & VERSION CONTROL
// ============================================================================

model EditHistory {
  id          String   @id @default(cuid())
  editorId    String

  // What was edited
  targetType  EditTargetType
  debateId    String?
  argumentId  String?

  // Changes
  fieldChanged String
  oldValue    String?
  newValue    String?

  // Context
  reason      String?

  createdAt   DateTime @default(now())

  editor      User     @relation(fields: [editorId], references: [id])
  debate      Debate?  @relation("DebateEdits", fields: [debateId], references: [id])
  argument    Argument? @relation("ArgumentEdits", fields: [argumentId], references: [id])

  @@map("edit_history")
}

enum EditTargetType {
  DEBATE
  ARGUMENT
  COMMENT
  MEDIA
}
