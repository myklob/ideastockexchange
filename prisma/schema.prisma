generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// ─── Prediction Market Models ────────────────────────────────────

model Claim {
  id               String        @id @default(cuid())
  title            String
  description      String
  category         String        @default("general")
  status           ClaimStatus   @default(ACTIVE)
  reasonRank       Float         @default(0.0)
  truthScore       Float         @default(0.0)
  logicalValidity  Float         @default(0.0)
  evidenceQuality  Float         @default(0.0)
  resolution       Resolution?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  resolvedAt       DateTime?

  liquidityPool    LiquidityPool?
  subArguments     SubArgument[]
  claimEvidence    ClaimEvidence[]
  shares           Share[]
  trades           Trade[]

  @@index([status])
  @@index([reasonRank])
  @@index([category])
}

enum ClaimStatus {
  ACTIVE
  RESOLVED_YES
  RESOLVED_NO
  EXPIRED
}

enum Resolution {
  YES
  NO
}

model LiquidityPool {
  id              String   @id @default(cuid())
  claimId         String   @unique
  yesShares       Float    @default(1000.0)
  noShares        Float    @default(1000.0)
  constantProduct Float    @default(1000000.0)
  totalVolume     Float    @default(0.0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  claim           Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
}

model Share {
  id               String    @id @default(cuid())
  userId           String
  claimId          String
  shareType        ShareType
  quantity         Float
  avgPurchasePrice Float
  createdAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id])
  claim            Claim     @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@unique([userId, claimId, shareType])
  @@index([userId])
  @@index([claimId])
}

enum ShareType {
  YES
  NO
}

model Trade {
  id            String    @id @default(cuid())
  userId        String
  claimId       String
  shareType     ShareType
  direction     TradeDirection
  quantity      Float
  pricePerShare Float
  totalCost     Float
  createdAt     DateTime  @default(now())

  user          User      @relation(fields: [userId], references: [id])
  claim         Claim     @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([claimId])
  @@index([createdAt])
}

enum TradeDirection {
  BUY
  SELL
}

model User {
  id             String   @id @default(cuid())
  username       String   @unique
  currentBalance Float    @default(10000.0)
  totalInvested  Float    @default(0.0)
  realizedPnl    Float    @default(0.0)
  roi            Float    @default(0.0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  shares         Share[]
  trades         Trade[]
}

model SubArgument {
  id              String            @id @default(cuid())
  claimId         String
  position        ArgumentPosition
  content         String
  logicalValidity Float             @default(0.0)
  evidenceQuality Float             @default(0.0)
  createdAt       DateTime          @default(now())

  claim           Claim             @relation(fields: [claimId], references: [id], onDelete: Cascade)
  claimEvidence   ClaimEvidence[]

  @@index([claimId])
}

enum ArgumentPosition {
  PRO
  CON
}

model ClaimEvidence {
  id               String             @id @default(cuid())
  claimId          String
  subArgumentId    String?
  sourceUrl        String?
  sourceType       EvidenceSourceType
  description      String
  reliabilityScore Float              @default(0.5)
  createdAt        DateTime           @default(now())

  claim            Claim              @relation(fields: [claimId], references: [id], onDelete: Cascade)
  subArgument      SubArgument?       @relation(fields: [subArgumentId], references: [id])

  @@index([claimId])
  @@index([subArgumentId])
}

enum EvidenceSourceType {
  PEER_REVIEWED
  INSTITUTIONAL
  JOURNALISTIC
  PRIMARY_SOURCE
  ANECDOTAL
  EXPERT_OPINION
}

// ─── Belief Analysis Models ──────────────────────────────────────

// Core belief - each belief gets its own analysis page
model Belief {
  id          Int      @id @default(autoincrement())
  slug        String   @unique
  statement   String
  category    String?
  subcategory String?
  deweyNumber String?
  positivity  Float    @default(0) // -100 to +100

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Arguments where this belief IS the reason (child)
  asArgument Argument[] @relation("ArgumentBelief")

  // Arguments attached TO this belief (parent)
  arguments Argument[] @relation("ParentBelief")

  evidence          Evidence[]
  objectiveCriteria ObjectiveCriteria[]
  valuesAnalysis    ValuesAnalysis?
  interestsAnalysis InterestsAnalysis?
  assumptions       Assumption[]
  costBenefitAnalysis CostBenefitAnalysis?
  impactAnalysis    ImpactAnalysis?
  compromises       Compromise[]
  obstacles         Obstacle[]
  biases            BiasEntry[]
  mediaResources    MediaResource[]
  legalEntries      LegalEntry[]

  upstreamMappings   BeliefMapping[] @relation("MappingChild")
  downstreamMappings BeliefMapping[] @relation("MappingParent")

  similarTo      SimilarBelief[] @relation("SimilarFrom")
  similarFrom    SimilarBelief[] @relation("SimilarTo")

  productReview  ProductReview?
}

enum LinkageClassification {
  DEDUCTIVE_PROOF
  STRONG_CAUSAL
  CONTEXTUAL
  ANECDOTAL
  IRRELEVANT
  NON_SEQUITUR
  CONTRADICTION
}

model Argument {
  id Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("ParentBelief", fields: [parentBeliefId], references: [id])

  beliefId Int
  belief   Belief @relation("ArgumentBelief", fields: [beliefId], references: [id])

  side         String // "agree" or "disagree"
  linkageScore Float  @default(0.1)
  impactScore  Float  @default(0)

  linkageType LinkageClassification @default(ANECDOTAL)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  linkageArguments LinkageArgument[]
  linkageVotes     LinkageVote[]
}

model LinkageArgument {
  id         Int      @id @default(autoincrement())
  argumentId Int
  argument   Argument @relation(fields: [argumentId], references: [id])
  side       String
  statement  String
  strength   Float    @default(0.5)
  createdAt  DateTime @default(now())
}

model LinkageVote {
  id         Int      @id @default(autoincrement())
  argumentId Int
  argument   Argument @relation(fields: [argumentId], references: [id])

  userId     String
  score      Float
  weight     Float    @default(1.0)

  direction    String?
  isRelevant   Boolean?
  strength     String?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([argumentId, userId])
  @@index([argumentId])
}

model Evidence {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "weakening"
  description String
  sourceUrl   String?
  evidenceType String @default("T3")

  sourceIndependenceWeight Float @default(0.5)
  replicationQuantity      Int   @default(1)
  conclusionRelevance      Float @default(0.5)
  replicationPercentage    Float @default(1.0)

  linkageScore Float @default(0.5)
  impactScore  Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ObjectiveCriteria {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description      String
  independenceScore Float @default(0.5)
  linkageScore     Float @default(0.5)
  criteriaType     String?
  totalScore       Float  @default(0)

  createdAt DateTime @default(now())
}

model ValuesAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supportingAdvertised String?
  supportingActual     String?
  opposingAdvertised   String?
  opposingActual       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model InterestsAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supporterInterests   String?
  opponentInterests    String?
  sharedInterests      String?
  conflictingInterests String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Assumption {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "accept" or "reject"
  statement  String
  strength   String @default("MODERATE")

  createdAt DateTime @default(now())
}

model CostBenefitAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  benefits          String?
  benefitLikelihood Float?
  costs             String?
  costLikelihood    Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ImpactAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  shortTermEffects    String?
  shortTermCosts      String?
  longTermEffects     String?
  longTermChanges     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Compromise {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description String
  createdAt   DateTime @default(now())
}

model Obstacle {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporter" or "opposition"
  description String
  createdAt   DateTime @default(now())
}

model BiasEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side     String
  biasType String
  description String?

  createdAt DateTime @default(now())
}

model MediaResource {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "supporting" or "opposing"
  mediaType  String // "book", "article", "podcast", "movie", "song"
  title      String
  author     String?
  url        String?

  createdAt DateTime @default(now())
}

model LegalEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "contradicting"
  description String
  jurisdiction String?

  createdAt DateTime @default(now())
}

model BeliefMapping {
  id       Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("MappingParent", fields: [parentBeliefId], references: [id])

  childBeliefId Int
  childBelief   Belief @relation("MappingChild", fields: [childBeliefId], references: [id])

  direction String // "upstream" or "downstream"
  side      String // "support" or "oppose"

  createdAt DateTime @default(now())
}

model SimilarBelief {
  id Int @id @default(autoincrement())

  fromBeliefId Int
  fromBelief   Belief @relation("SimilarFrom", fields: [fromBeliefId], references: [id])

  toBeliefId Int
  toBelief   Belief @relation("SimilarTo", fields: [toBeliefId], references: [id])

  variant String // "extreme" or "moderate"

  createdAt DateTime @default(now())
}

// ─── Product Review Models ──────────────────────────────────────

// Core product review - links to a Belief ("X makes the best Y")
model ProductReview {
  id          Int      @id @default(autoincrement())
  slug        String   @unique
  productName String   // e.g., "Ford F-150"
  brand       String   // e.g., "Ford"
  claim       String   // e.g., "Ford makes the best trucks"

  // Category hierarchy: Product Type > Subcategory > Brand/Model
  categoryType    String   // e.g., "Trucks"
  categorySubtype String?  // e.g., "Full-size Pickup"

  // Scores computed from the linked belief's argument tree
  overallScore    Float    @default(0)
  categoryRank    Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Link to the belief system for argument scoring
  beliefId  Int?     @unique
  belief    Belief?  @relation(fields: [beliefId], references: [id])

  // Product-specific analysis sections
  performanceData  ProductPerformance[]
  tradeoffs        ProductTradeoff[]
  alternatives     ProductAlternative[]
  userProfiles     ProductUserProfile[]
  awards           ProductAward[]
  ecosystemItems   ProductEcosystem[]

  @@index([categoryType])
  @@index([overallScore])
  @@index([brand])
}

// Per-criterion performance data with evidence quality tiers
model ProductPerformance {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  criterion       String   // e.g., "Towing Capacity"
  measurement     String   // e.g., "14,000 lbs"
  evidenceTier    Int      @default(3) // 1-4 (T1=lab tested, T4=anecdotal)
  comparisonToAvg String   @default("Same") // "Better", "Worse", "Same"
  sourceUrl       String?

  createdAt DateTime @default(now())

  @@index([productReviewId])
}

// Design trade-offs: what the product optimizes for vs. sacrifices
model ProductTradeoff {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  side            String  // "optimizes" or "sacrifices"
  category        String  // "advertised" or "actual"
  description     String

  createdAt DateTime @default(now())

  @@index([productReviewId])
}

// Alternative products (premium, budget, or lateral)
model ProductAlternative {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  alternativeName String
  tier            String  // "premium", "budget", or "lateral"
  keyAdvantage    String
  linkSlug        String? // Optional link to that product's review

  createdAt DateTime @default(now())

  @@index([productReviewId])
}

// User profile fit analysis
model ProductUserProfile {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  side            String  // "ideal" or "not_ideal"
  description     String

  createdAt DateTime @default(now())

  @@index([productReviewId])
}

// Awards and certifications
model ProductAward {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  side            String  // "independent" or "manufacturer"
  title           String
  details         String?

  createdAt DateTime @default(now())

  @@index([productReviewId])
}

// Product ecosystem: upstream dependencies, downstream additions, lock-in
model ProductEcosystem {
  id              Int    @id @default(autoincrement())
  productReviewId Int
  productReview   ProductReview @relation(fields: [productReviewId], references: [id], onDelete: Cascade)

  category        String  // "upstream", "downstream", or "lockin"
  description     String

  createdAt DateTime @default(now())

  @@index([productReviewId])
}
