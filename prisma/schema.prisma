// Prisma schema for IdeaStockExchange
// A comprehensive debate platform with integrated media lists and social features

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  username      String   @unique
  passwordHash  String
  bio           String?
  avatarUrl     String?
  website       String?
  location      String?

  // Status
  isVerified    Boolean  @default(false)
  isModerator   Boolean  @default(false)
  isAdmin       Boolean  @default(false)
  isBanned      Boolean  @default(false)
  bannedUntil   DateTime?

  // Reputation & Stats
  karma         Int      @default(0)
  reputation    Int      @default(0)

  // Privacy
  emailVisible  Boolean  @default(false)
  profilePublic Boolean  @default(true)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastSeenAt    DateTime @default(now())

  // Relations - Content
  debates              Debate[]
  arguments            Argument[]
  media                Media[]
  comments             Comment[]
  drafts               Draft[]

  // Relations - Engagement
  votes                Vote[]
  commentVotes         CommentVote[]
  follows              Follow[]        @relation("Follower")
  followers            Follow[]        @relation("Following")
  debateSubscriptions  DebateSubscription[]

  // Relations - Social
  sentMessages         DirectMessage[] @relation("Sender")
  receivedMessages     DirectMessage[] @relation("Recipient")
  blockedUsers         UserBlock[]     @relation("Blocker")
  blockedBy            UserBlock[]     @relation("Blocked")

  // Relations - Moderation
  reports              Report[]
  moderationActions    ModerationAction[]
  receivedActions      ModerationAction[] @relation("Target")

  // Relations - Merging
  mergeProposals       MergeProposal[]
  mergeVotes           MergeVote[]

  // Relations - Education
  ownedClassrooms      Classroom[]     @relation("Teacher")
  enrolledClassrooms   ClassroomStudent[]
  assignments          Assignment[]
  submissions          Submission[]

  // Relations - Templates
  templates            Template[]

  // Relations - Achievements
  achievements         UserAchievement[]

  // Relations - Notifications
  notifications        Notification[]

  // Relations - Edit History
  edits                EditHistory[]

  @@map("users")
}

// User statistics (for analytics and leaderboards)
model UserStats {
  id                String   @id @default(cuid())
  userId            String   @unique

  // Counts
  debatesCreated    Int      @default(0)
  argumentsPosted   Int      @default(0)
  commentsPosted    Int      @default(0)
  mediaAdded        Int      @default(0)

  // Engagement
  upvotesReceived   Int      @default(0)
  downvotesReceived Int      @default(0)
  upvotesGiven      Int      @default(0)
  downvotesGiven    Int      @default(0)

  // Quality metrics
  avgTruthScore     Float?
  avgImportanceScore Float?
  avgRelevanceScore Float?

  updatedAt         DateTime @updatedAt

  @@map("user_stats")
}

// Follow relationships (users following users)
model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User     @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

// User blocking
model UserBlock {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())

  blocker   User     @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("user_blocks")
}

// ============================================================================
// DEBATES
// ============================================================================

model Debate {
  id            String   @id @default(cuid())
  title         String
  description   String?
  thesis        String?  // Main claim to be debated

  // Metadata
  isPublic      Boolean  @default(true)
  tags          String[]
  category      String?

  // Settings
  allowComments Boolean  @default(true)
  requireModeration Boolean @default(false)
  isLocked      Boolean  @default(false)
  isFeatured    Boolean  @default(false)

  // Template
  isTemplate    Boolean  @default(false)
  templateId    String?

  // Stats
  viewCount     Int      @default(0)
  participantCount Int   @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  authorId      String

  // Relations
  author        User     @relation(fields: [authorId], references: [id])
  arguments     Argument[]
  subscriptions DebateSubscription[]
  template      Template? @relation(fields: [templateId], references: [id])
  classroomDebates ClassroomDebate[]
  editHistory   EditHistory[] @relation("DebateEdits")

  @@map("debates")
}

// Debate subscriptions (users following debates)
model DebateSubscription {
  id          String   @id @default(cuid())
  userId      String
  debateId    String

  // Notification preferences
  notifyOnArgument Boolean @default(true)
  notifyOnComment  Boolean @default(true)
  notifyOnMerge    Boolean @default(false)

  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  @@unique([userId, debateId])
  @@map("debate_subscriptions")
}

// ============================================================================
// ARGUMENTS
// ============================================================================

model Argument {
  id            String   @id @default(cuid())
  content       String
  summary       String?  // Short summary for overview mode

  // Position in debate
  debateId      String
  parentId      String?
  authorId      String
  position      ArgumentPosition @default(NEUTRAL)

  // Status
  status        ArgumentStatus @default(PUBLISHED)
  isDraft       Boolean  @default(false)
  isDeleted     Boolean  @default(false)
  deletedAt     DateTime?

  // Scoring
  truthScore        Float?
  importanceScore   Float?
  relevanceScore    Float?
  reasonRank        Float?
  impactScore       Float?  // Kialo-style impact rating

  // Stats
  viewCount         Int      @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  debate        Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)
  parent        Argument? @relation("ArgumentHierarchy", fields: [parentId], references: [id])
  children      Argument[] @relation("ArgumentHierarchy")
  author        User     @relation(fields: [authorId], references: [id])
  media         ArgumentMedia[]
  votes         Vote[]
  comments      Comment[]

  // Merging
  mergeProposalsSource MergeProposal[] @relation("SourceArgument")
  mergeProposalsTarget MergeProposal[] @relation("TargetArgument")
  mergedFrom    ArgumentMerge[] @relation("MergedFrom")
  mergedInto    ArgumentMerge[] @relation("MergedInto")

  // Reports and moderation
  reports       Report[]
  moderationActions ModerationAction[] @relation("ArgumentActions")

  // Edit history
  editHistory   EditHistory[] @relation("ArgumentEdits")

  // Suggestions
  suggestedEdits SuggestedEdit[]

  @@map("arguments")
}

enum ArgumentPosition {
  PRO
  CON
  NEUTRAL
}

enum ArgumentStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  ARCHIVED
  MERGED
}

// ============================================================================
// COMMENTS (Discussion Threads)
// ============================================================================

model Comment {
  id          String   @id @default(cuid())
  content     String
  argumentId  String
  authorId    String
  parentId    String?  // For nested comments

  // Status
  isDeleted   Boolean  @default(false)
  isEdited    Boolean  @default(false)
  deletedAt   DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  author      User     @relation(fields: [authorId], references: [id])
  parent      Comment? @relation("CommentHierarchy", fields: [parentId], references: [id])
  children    Comment[] @relation("CommentHierarchy")
  votes       CommentVote[]
  reports     Report[]

  @@map("comments")
}

model CommentVote {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  voteType  VoteType
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("comment_votes")
}

// ============================================================================
// VOTES
// ============================================================================

model Vote {
  id          String   @id @default(cuid())
  userId      String
  argumentId  String
  voteType    VoteType
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])
  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([userId, argumentId])
  @@map("votes")
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

// ============================================================================
// MEDIA
// ============================================================================

model Media {
  id            String   @id @default(cuid())
  title         String
  description   String?
  url           String?
  mediaType     MediaType

  // Metadata
  thumbnailUrl  String?
  author        String?
  publishDate   DateTime?
  isbn          String?
  duration      Int?

  // Source credibility
  sourceUrl     String?
  credibilityScore Float?
  biasScore     Float?

  // Status
  isVerified    Boolean  @default(false)
  verifiedBy    String?
  verifiedAt    DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  authorId      String

  // Relations
  creator       User     @relation(fields: [authorId], references: [id])
  arguments     ArgumentMedia[]
  reports       Report[]

  @@map("media")
}

enum MediaType {
  BOOK
  VIDEO
  ARTICLE
  IMAGE
  PODCAST
  DOCUMENTARY
  PAPER
  WEBSITE
}

model ArgumentMedia {
  id          String   @id @default(cuid())
  argumentId  String
  mediaId     String
  position    MediaPosition
  relevance   Float?
  createdAt   DateTime @default(now())

  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
  media       Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  @@unique([argumentId, mediaId])
  @@map("argument_media")
}

enum MediaPosition {
  SUPPORTS
  REFUTES
  NEUTRAL
}

// ============================================================================
// ARGUMENT MERGING
// ============================================================================

model MergeProposal {
  id              String   @id @default(cuid())
  sourceArgumentId String
  targetArgumentId String
  proposerId      String

  reason          String
  status          MergeStatus @default(PENDING)

  createdAt       DateTime @default(now())
  resolvedAt      DateTime?
  resolvedBy      String?

  // Relations
  sourceArgument  Argument @relation("SourceArgument", fields: [sourceArgumentId], references: [id], onDelete: Cascade)
  targetArgument  Argument @relation("TargetArgument", fields: [targetArgumentId], references: [id], onDelete: Cascade)
  proposer        User     @relation(fields: [proposerId], references: [id])
  votes           MergeVote[]

  @@map("merge_proposals")
}

model MergeVote {
  id          String   @id @default(cuid())
  proposalId  String
  userId      String
  approve     Boolean
  createdAt   DateTime @default(now())

  proposal    MergeProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id])

  @@unique([proposalId, userId])
  @@map("merge_votes")
}

model ArgumentMerge {
  id          String   @id @default(cuid())
  fromId      String
  intoId      String
  mergedBy    String
  mergedAt    DateTime @default(now())

  from        Argument @relation("MergedFrom", fields: [fromId], references: [id])
  into        Argument @relation("MergedInto", fields: [intoId], references: [id])

  @@map("argument_merges")
}

enum MergeStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

// ============================================================================
// SUGGESTED EDITS
// ============================================================================

model SuggestedEdit {
  id          String   @id @default(cuid())
  argumentId  String
  suggesterId String

  originalContent String
  suggestedContent String
  reason      String?

  status      SuggestedEditStatus @default(PENDING)

  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?

  argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@map("suggested_edits")
}

enum SuggestedEditStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// ============================================================================
// DRAFTS (Auto-save)
// ============================================================================

model Draft {
  id          String   @id @default(cuid())
  userId      String

  // Content
  type        DraftType
  title       String?
  content     String

  // Context
  debateId    String?
  argumentId  String?  // Parent argument if replying
  position    ArgumentPosition?

  // Metadata
  autoSaved   Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("drafts")
}

enum DraftType {
  DEBATE
  ARGUMENT
  COMMENT
  MEDIA
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

model Notification {
  id          String   @id @default(cuid())
  userId      String

  type        NotificationType
  title       String
  message     String

  // Context
  debateId    String?
  argumentId  String?
  commentId   String?
  fromUserId  String?

  // Status
  isRead      Boolean  @default(false)
  readAt      DateTime?

  // Links
  actionUrl   String?

  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

enum NotificationType {
  NEW_ARGUMENT
  NEW_COMMENT
  NEW_REPLY
  VOTE_RECEIVED
  MENTION
  FOLLOW
  MERGE_PROPOSAL
  MERGE_APPROVED
  REPORT_RESOLVED
  MODERATION_ACTION
  ASSIGNMENT_CREATED
  ASSIGNMENT_GRADED
  MESSAGE_RECEIVED
}

// ============================================================================
// DIRECT MESSAGES
// ============================================================================

model DirectMessage {
  id          String   @id @default(cuid())
  senderId    String
  recipientId String

  content     String

  isRead      Boolean  @default(false)
  readAt      DateTime?

  isDeleted   Boolean  @default(false)
  deletedBy   String?

  createdAt   DateTime @default(now())

  sender      User     @relation("Sender", fields: [senderId], references: [id])
  recipient   User     @relation("Recipient", fields: [recipientId], references: [id])

  @@map("direct_messages")
}

// ============================================================================
// MODERATION
// ============================================================================

model Report {
  id          String   @id @default(cuid())
  reporterId  String

  // What's being reported
  targetType  ReportTargetType
  argumentId  String?
  commentId   String?
  mediaId     String?
  userId      String?  // Reporting a user

  reason      ReportReason
  description String?

  status      ReportStatus @default(PENDING)

  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?
  resolution  String?

  reporter    User     @relation(fields: [reporterId], references: [id])
  argument    Argument? @relation(fields: [argumentId], references: [id])
  comment     Comment?  @relation(fields: [commentId], references: [id])
  media       Media?    @relation(fields: [mediaId], references: [id])

  @@map("reports")
}

enum ReportTargetType {
  ARGUMENT
  COMMENT
  MEDIA
  USER
  DEBATE
}

enum ReportReason {
  SPAM
  HARASSMENT
  MISINFORMATION
  OFF_TOPIC
  INAPPROPRIATE
  DUPLICATE
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

model ModerationAction {
  id          String   @id @default(cuid())
  moderatorId String
  targetUserId String?

  // What was moderated
  targetType  ModerationTargetType
  argumentId  String?
  commentId   String?
  debateId    String?

  action      ModerationType
  reason      String
  duration    Int?     // Duration in hours for temp bans

  createdAt   DateTime @default(now())
  expiresAt   DateTime?

  moderator   User     @relation(fields: [moderatorId], references: [id])
  targetUser  User?    @relation("Target", fields: [targetUserId], references: [id])
  argument    Argument? @relation("ArgumentActions", fields: [argumentId], references: [id])

  @@map("moderation_actions")
}

enum ModerationTargetType {
  ARGUMENT
  COMMENT
  DEBATE
  USER
  MEDIA
}

enum ModerationType {
  DELETE
  HIDE
  LOCK
  BAN_USER
  TEMP_BAN
  MUTE
  WARNING
  APPROVE
  FEATURE
}

// ============================================================================
// TEMPLATES
// ============================================================================

model Template {
  id          String   @id @default(cuid())
  name        String
  description String?

  // Template structure
  thesisTemplate String
  categories  String[]
  tags        String[]

  // Predefined arguments
  structure   Json?    // JSON structure of initial arguments

  // Settings
  isPublic    Boolean  @default(true)
  usageCount  Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  creatorId   String

  creator     User     @relation(fields: [creatorId], references: [id])
  debates     Debate[]

  @@map("templates")
}

// ============================================================================
// EDUCATION / CLASSROOMS
// ============================================================================

model Classroom {
  id          String   @id @default(cuid())
  name        String
  description String?

  code        String   @unique  // Join code

  isActive    Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  teacherId   String

  teacher     User     @relation("Teacher", fields: [teacherId], references: [id])
  students    ClassroomStudent[]
  debates     ClassroomDebate[]
  assignments Assignment[]

  @@map("classrooms")
}

model ClassroomStudent {
  id          String   @id @default(cuid())
  classroomId String
  studentId   String

  enrolledAt  DateTime @default(now())
  isActive    Boolean  @default(true)

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)

  @@unique([classroomId, studentId])
  @@map("classroom_students")
}

model ClassroomDebate {
  id          String   @id @default(cuid())
  classroomId String
  debateId    String

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  @@unique([classroomId, debateId])
  @@map("classroom_debates")
}

model Assignment {
  id          String   @id @default(cuid())
  classroomId String
  teacherId   String

  title       String
  description String?
  instructions String?

  // Requirements
  debateId    String?
  minArguments Int?
  minMediaSources Int?

  // Grading
  totalPoints Int      @default(100)

  // Dates
  dueDate     DateTime
  createdAt   DateTime @default(now())

  classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
  teacher     User     @relation(fields: [teacherId], references: [id])
  submissions Submission[]

  @@map("assignments")
}

model Submission {
  id          String   @id @default(cuid())
  assignmentId String
  studentId   String

  // Content
  content     String?
  argumentIds String[] // Arguments submitted

  // Grading
  status      SubmissionStatus @default(PENDING)
  grade       Float?
  maxGrade    Float?
  feedback    String?

  submittedAt DateTime @default(now())
  gradedAt    DateTime?

  assignment  Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  student     User     @relation(fields: [studentId], references: [id])

  @@unique([assignmentId, studentId])
  @@map("submissions")
}

enum SubmissionStatus {
  PENDING
  SUBMITTED
  GRADED
  LATE
}

// ============================================================================
// ACHIEVEMENTS & GAMIFICATION
// ============================================================================

model Achievement {
  id          String   @id @default(cuid())
  name        String
  description String
  icon        String?

  // Criteria
  type        AchievementType
  threshold   Int      // e.g., 10 debates, 100 karma, etc.

  // Rewards
  karmaReward Int      @default(0)

  createdAt   DateTime @default(now())

  users       UserAchievement[]

  @@map("achievements")
}

enum AchievementType {
  DEBATES_CREATED
  ARGUMENTS_POSTED
  KARMA_EARNED
  MEDIA_CONTRIBUTED
  VOTES_RECEIVED
  STREAK_DAYS
  MODERATOR_ACTIONS
  HELPFUL_VOTES
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String

  unlockedAt    DateTime @default(now())
  progress      Int      @default(0)

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id])

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// ============================================================================
// EDIT HISTORY & VERSION CONTROL
// ============================================================================

model EditHistory {
  id          String   @id @default(cuid())
  editorId    String

  // What was edited
  targetType  EditTargetType
  debateId    String?
  argumentId  String?

  // Changes
  fieldChanged String
  oldValue    String?
  newValue    String?

  // Context
  reason      String?

  createdAt   DateTime @default(now())

  editor      User     @relation(fields: [editorId], references: [id])
  debate      Debate?  @relation("DebateEdits", fields: [debateId], references: [id])
  argument    Argument? @relation("ArgumentEdits", fields: [argumentId], references: [id])

  @@map("edit_history")
}

enum EditTargetType {
  DEBATE
  ARGUMENT
  COMMENT
  MEDIA
}
