generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core claim: the asset being traded.
model Claim {
  id               String        @id @default(cuid())
  title            String
  description      String
  category         String        @default("general")
  status           ClaimStatus   @default(ACTIVE)
  reasonRank       Float         @default(0.0)
  truthScore       Float         @default(0.0)
  logicalValidity  Float         @default(0.0)
  evidenceQuality  Float         @default(0.0)
  resolution       Resolution?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  resolvedAt       DateTime?

  liquidityPool    LiquidityPool?
  subArguments     SubArgument[]
  evidence         Evidence[]
  shares           Share[]
  trades           Trade[]

  @@index([status])
  @@index([reasonRank])
  @@index([category])
}

enum ClaimStatus {
  ACTIVE
  RESOLVED_YES
  RESOLVED_NO
  EXPIRED
}

enum Resolution {
  YES
  NO
}

// CPMM liquidity pool: determines Market Price via constant product formula.
model LiquidityPool {
  id              String   @id @default(cuid())
  claimId         String   @unique
  yesShares       Float    @default(1000.0)
  noShares        Float    @default(1000.0)
  constantProduct Float    @default(1000000.0)
  totalVolume     Float    @default(0.0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  claim           Claim    @relation(fields: [claimId], references: [id], onDelete: Cascade)
}

// Individual share holdings.
model Share {
  id               String    @id @default(cuid())
  userId           String
  claimId          String
  shareType        ShareType
  quantity         Float
  avgPurchasePrice Float
  createdAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id])
  claim            Claim     @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@unique([userId, claimId, shareType])
  @@index([userId])
  @@index([claimId])
}

enum ShareType {
  YES
  NO
}

// Trade history: every transaction recorded.
model Trade {
  id            String    @id @default(cuid())
  userId        String
  claimId       String
  shareType     ShareType
  direction     TradeDirection
  quantity      Float
  pricePerShare Float
  totalCost     Float
  createdAt     DateTime  @default(now())

  user          User      @relation(fields: [userId], references: [id])
  claim         Claim     @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([claimId])
  @@index([createdAt])
}

enum TradeDirection {
  BUY
  SELL
}

// User account: capital balance and portfolio metrics.
model User {
  id             String        @id @default(cuid())
  username       String        @unique
  currentBalance Float         @default(10000.0)
  totalInvested  Float         @default(0.0)
  realizedPnl    Float         @default(0.0)
  roi            Float         @default(0.0)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  shares         Share[]
  trades         Trade[]
}

// Sub-arguments: pro and con analysis attached to a claim.
model SubArgument {
  id              String      @id @default(cuid())
  claimId         String
  position        ArgumentPosition
  content         String
  logicalValidity Float       @default(0.0)
  evidenceQuality Float       @default(0.0)
  createdAt       DateTime    @default(now())

  claim           Claim       @relation(fields: [claimId], references: [id], onDelete: Cascade)
  evidence        Evidence[]

  @@index([claimId])
}

enum ArgumentPosition {
  PRO
  CON
}

// Evidence: supporting data linked to claims or sub-arguments.
model Evidence {
  id               String             @id @default(cuid())
  claimId          String
  subArgumentId    String?
  sourceUrl        String?
  sourceType       EvidenceSourceType
  description      String
  reliabilityScore Float              @default(0.5)
  createdAt        DateTime           @default(now())

  claim            Claim              @relation(fields: [claimId], references: [id], onDelete: Cascade)
  subArgument      SubArgument?       @relation(fields: [subArgumentId], references: [id])

  @@index([claimId])
  @@index([subArgumentId])
}

enum EvidenceSourceType {
  PEER_REVIEWED
  INSTITUTIONAL
  JOURNALISTIC
  PRIMARY_SOURCE
  ANECDOTAL
  EXPERT_OPINION
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// Core belief - each belief gets its own page
model Belief {
  id          Int      @id @default(autoincrement())
  slug        String   @unique
  statement   String   // The belief statement
  category    String?  // Topic category
  subcategory String?  // Topic subcategory
  deweyNumber String?  // Dewey classification
  positivity  Float    @default(0) // -100 to +100

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Arguments where this belief IS the reason (child)
  asArgument Argument[] @relation("ArgumentBelief")

  // Arguments attached TO this belief (parent)
  arguments Argument[] @relation("ParentBelief")

  // Evidence attached to this belief
  evidence Evidence[]

  // Objective criteria for this belief
  objectiveCriteria ObjectiveCriteria[]

  // Values analysis
  valuesAnalysis ValuesAnalysis?

  // Interests analysis
  interestsAnalysis InterestsAnalysis?

  // Assumptions
  assumptions Assumption[]

  // Cost-benefit analysis
  costBenefitAnalysis CostBenefitAnalysis?

  // Short vs long term impacts
  impactAnalysis ImpactAnalysis?

  // Compromise solutions
  compromises Compromise[]

  // Obstacles to resolution
  obstacles Obstacle[]

  // Biases
  biases BiasEntry[]

  // Media resources
  mediaResources MediaResource[]

  // Legal framework
  legalEntries LegalEntry[]

  // Belief mapping (general to specific)
  upstreamMappings   BeliefMapping[] @relation("MappingChild")
  downstreamMappings BeliefMapping[] @relation("MappingParent")

  // Similar beliefs
  similarTo      SimilarBelief[] @relation("SimilarFrom")
  similarFrom    SimilarBelief[] @relation("SimilarTo")
}

// Classification of the logical connection type between two beliefs
enum LinkageClassification {
  DEDUCTIVE_PROOF  // Score ~1.0: If premise true, conclusion must be true
  STRONG_CAUSAL    // Score 0.7-0.9: Direct causal evidence
  CONTEXTUAL       // Score 0.4-0.6: Helpful context but not decisive
  ANECDOTAL        // Score 0.1-0.3: Tangential or minor example
  IRRELEVANT       // Score 0.0: No bearing on the conclusion
  NON_SEQUITUR     // Score 0.0: Flagged as logical disconnect
  CONTRADICTION    // Score -1.0: Premise disproves conclusion
}

// An argument linking one belief (reason) to another belief (conclusion)
// Each reason is itself a belief with its own page
model Argument {
  id Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("ParentBelief", fields: [parentBeliefId], references: [id])

  // The reason (which is itself a belief with its own page)
  beliefId Int
  belief   Belief @relation("ArgumentBelief", fields: [beliefId], references: [id])

  side         String // "agree" or "disagree"
  linkageScore Float  @default(0.1) // -1.0 to 1.0 (start low until community validates)
  impactScore  Float  @default(0)   // computed

  // Linkage classification from diagnostic wizard
  linkageType LinkageClassification @default(ANECDOTAL)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Linkage arguments - reasons to agree/disagree with the linkage itself
  linkageArguments LinkageArgument[]

  // Community votes on the linkage strength (logic, not truth)
  linkageVotes LinkageVote[]
}

// Arguments about whether a linkage between two beliefs is valid
model LinkageArgument {
  id         Int      @id @default(autoincrement())
  argumentId Int
  argument   Argument @relation(fields: [argumentId], references: [id])
  side       String   // "agree" or "disagree" with the linkage
  statement  String
  strength   Float    @default(0.5)
  createdAt  DateTime @default(now())
}

// Community vote on the logical relevance (linkage) of an argument
// Users vote on the LOGIC, not the Truth
model LinkageVote {
  id         Int      @id @default(autoincrement())
  argumentId Int
  argument   Argument @relation(fields: [argumentId], references: [id])

  userId     String   // Reference to User
  score      Float    // -1.0 to 1.0 (user's linkage assessment)
  weight     Float    @default(1.0) // Based on user reputation in "Logic"

  // Diagnostic answers that produced this score
  direction    String?  // "support" or "oppose"
  isRelevant   Boolean? // Blue Sky filter: does it force a change of mind?
  strength     String?  // "proof", "strong", "context", "weak"

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([argumentId, userId])
  @@index([argumentId])
}

// Evidence supporting or weakening a belief
model Evidence {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "weakening"
  description String
  sourceUrl   String?
  evidenceType String @default("T3") // T1=Peer-reviewed, T2=Expert, T3=Journalism, T4=Opinion

  // Evidence Verification Score components
  sourceIndependenceWeight Float @default(0.5) // ESIW
  replicationQuantity      Int   @default(1)   // ERQ
  conclusionRelevance      Float @default(0.5) // ECRS
  replicationPercentage    Float @default(1.0) // ERP

  linkageScore Float @default(0.5)
  impactScore  Float @default(0) // computed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Objective criteria for measuring belief strength
model ObjectiveCriteria {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description      String
  independenceScore Float @default(0.5)
  linkageScore     Float @default(0.5)
  criteriaType     String? // e.g. "market value", "scientific judgment", "precedent"
  totalScore       Float  @default(0) // computed

  createdAt DateTime @default(now())
}

// Core values conflict analysis
model ValuesAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supportingAdvertised String? // What supporters claim
  supportingActual     String? // What actually motivates supporters
  opposingAdvertised   String? // What opponents claim
  opposingActual       String? // What actually motivates opponents

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Interests & motivations analysis
model InterestsAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  supporterInterests   String? // Numbered list
  opponentInterests    String? // Numbered list
  sharedInterests      String? // Numbered list
  conflictingInterests String? // Numbered list

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Foundational assumptions
model Assumption {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "accept" or "reject"
  statement  String
  strength   String @default("MODERATE") // CRITICAL, STRONG, MODERATE, WEAK

  createdAt DateTime @default(now())
}

// Cost-benefit analysis
model CostBenefitAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  benefits          String? // improvements, who gains, positive externalities
  benefitLikelihood Float?
  costs             String? // problems, who loses, negative externalities
  costLikelihood    Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Short vs long-term impact analysis
model ImpactAnalysis {
  id       Int    @id @default(autoincrement())
  beliefId Int    @unique
  belief   Belief @relation(fields: [beliefId], references: [id])

  shortTermEffects    String? // 0-2 years
  shortTermCosts      String? // transition costs
  longTermEffects     String? // 5+ years
  longTermChanges     String? // structural changes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Compromise solutions
model Compromise {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  description String
  createdAt   DateTime @default(now())
}

// Obstacles to resolution
model Obstacle {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporter" or "opposition"
  description String
  createdAt   DateTime @default(now())
}

// Bias entries
model BiasEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side     String // "supporter" or "opponent"
  biasType String // CONFIRMATION_BIAS, ANCHORING, etc.
  description String?

  createdAt DateTime @default(now())
}

// Media resources
model MediaResource {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side       String // "supporting" or "opposing"
  mediaType  String // "book", "article", "podcast", "movie", "song"
  title      String
  author     String?
  url        String?

  createdAt DateTime @default(now())
}

// Legal framework
model LegalEntry {
  id       Int    @id @default(autoincrement())
  beliefId Int
  belief   Belief @relation(fields: [beliefId], references: [id])

  side        String // "supporting" or "contradicting"
  description String
  jurisdiction String? // "local", "state", "federal", "international"

  createdAt DateTime @default(now())
}

// General to specific belief mapping
model BeliefMapping {
  id       Int @id @default(autoincrement())

  parentBeliefId Int
  parentBelief   Belief @relation("MappingParent", fields: [parentBeliefId], references: [id])

  childBeliefId Int
  childBelief   Belief @relation("MappingChild", fields: [childBeliefId], references: [id])

  direction String // "upstream" (more general) or "downstream" (more specific)
  side      String // "support" or "oppose"

  createdAt DateTime @default(now())
}

// Similar beliefs
model SimilarBelief {
  id Int @id @default(autoincrement())

  fromBeliefId Int
  fromBelief   Belief @relation("SimilarFrom", fields: [fromBeliefId], references: [id])

  toBeliefId Int
  toBelief   Belief @relation("SimilarTo", fields: [toBeliefId], references: [id])

  variant String // "extreme" or "moderate"

  createdAt DateTime @default(now())
}
